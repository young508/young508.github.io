<!DOCTYPE html>


<html lang="zh">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="hexo blog" />
   
  <meta name="description" content="young blog write my world" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     young blog write my world
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/young508"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">YOUNG BLOG</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-TCPIP协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2020/11/24/TCPIP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-11-24T03:05:01.911Z" itemprop="datePublished">2020-11-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><blockquote>
<p>现代网络系统是基于TCP/IP协议族的基础上来运作的。我们开发中常用的HTTP协议只是其内部的一个子集</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>计算机与网络设备要相互通信，那么双方之间必须基于相同的方法。或者说不通的硬件，操作系统之间的通信，必须基于一套规则，我们常把这套规则称为协议（Protocal）</p>
<p>我们一般把互联网相关联的协议集合起来统称为TCP/IP协议族</p>
<h3 id="TCP-IP分层"><a href="#TCP-IP分层" class="headerlink" title="TCP/IP分层"></a>TCP/IP分层</h3><blockquote>
<p>从上到下，一般分为：应用层，传输层，网络层，数据链路层，每层都有自己对应的协议</p>
</blockquote>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层决定了向用户提供应用服务时通信的活动</p>
<p>TCP/IP协议族内预存了各类通用的应用服务。比如FTP/DNS。我们最常用的HTTP也就是处于该层</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层对上层应用层，提供处于网络链接中的<strong>两台计算机之间</strong>的数据传输。</p>
<p>TCP（Transmission Control Protocal，传输控制协议）和UDP（User Date Protocal，用户数据包协议）处于该层</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络用来处理在网络上流动的数据包。数据包是网络传输的最小数据单元。该层规定了通过怎样的路径到达对方计算机，并把数据包传给对方。</p>
<p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层起的作用救赎在众多的选项中选择一个传输数显</p>
<p>IP协议处于该层</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>用来处理链接网络的硬件设备。一般理解的硬件设备都处于该层。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议的作用是<strong>找到对方</strong>。为了保证找到的就是要找的那个人，最重要的两个条件是IP地址和MAC地址（Media Access Control Address）</p>
<ul>
<li><p>IP地址</p>
<ul>
<li><p>指明了节点被分配到地址，是网络上分配到地址，可变。</p>
</li>
<li><p>IPV4地址一般分为abcde5类</p>
<ul>
<li>1.0.0.0-1+127</li>
<li>128-128+63</li>
<li>192-192+31</li>
<li>224-224+15</li>
<li>240-240+15</li>
</ul>
</li>
<li><p>以下列出留用的内部私有地址</p>
<ul>
<li><p>10.0.0.0–10.255.255.255</p>
</li>
<li><p>172.16.0.0–172.31.255.255</p>
</li>
<li><p>192.168.0.0–192.168.255.255</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MAC地址</p>
<ul>
<li>是网卡生产时唯一确定的地址，一般不可变</li>
</ul>
</li>
<li><p>IP间的通信依赖MAC地址。网络在通信的过程中，信息会被中转才会传到目标设备。这是，一般会ARP（Address Resolution Protocal）协议，这是一种用以解析地址到协议，根据通信方的IP地址可以反查出对应的MAC地址</p>
</li>
</ul>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP可以提供可靠的字节流服务</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><blockquote>
<p>三次握手的目的：为了让客户端和服务端都能知道自己的发送和接收服务都是正常的</p>
</blockquote>
<ul>
<li>客户端发送报文给服务端，服务端接收到了，明白到：客户端发送正常，服务端接收正常</li>
<li>服务端发送报文给客户端，客户端接受到了，明白到：客户端发送，接收正常，服务发送，接收正常</li>
<li>客户端在发送报文给客户端，告诉服务端我可以发送了，服务端接收到了，明白了：客户端发送，接收正常，服务端发送，接收正常，明白客户端要开始发送数据了</li>
<li>握手的时候，通过syn确保同一次握手过程，seq，ack确保握手的步骤</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><blockquote>
<p>四次挥手的目的：双方在数据交互完毕后可以正式断开链接</p>
</blockquote>
<ul>
<li>客户端发送final给服务端：服务端接收到，明白了客户端要停止发送了</li>
<li>服务端回复给客户端：客户端明白了，此时我可以停止发送消息了（此时客户端还可以接收消息）</li>
<li>服务端再发送final消息给客户端：客户端明白了，服务端要停止发送消息了</li>
<li>客户端回复服务端：服务端明白了，我可以停止发送功能了，然后两者断开链接</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>HTTP是无状态协议，即请求本身不会对通信状态做保存</li>
<li>通过keep-alive保存持久链接</li>
<li>管线化技术可以同时发送多个请求</li>
<li>通过cookie进行状态管理</li>
</ul>
<h3 id="请求内容"><a href="#请求内容" class="headerlink" title="请求内容"></a>请求内容</h3><h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>对称加密对一种，一般对称加密使用同一个密钥进行加密和解密</p>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>非对称加密的一种，一般是通过一对公钥和私钥进行加解密，公钥加密的数据，只要私钥可以解密，所以公钥可以公开。</p>
<h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p>client端<br>1.server端生成RSA公钥和私钥对，通过api将公钥返回给client端<br>2.client端<strong>自己生成AES密钥</strong>–aeskey<br>3.client端利用aeskey加密明文json数据，得到请求数据encryptData<br>4.client端使用RSA公钥加密AES密钥aeskey，得到encryptAesData<br>5.clinet端将encryptAesData作为请求头，encryptData作为请求体，发送到server端</p>
<p>server端<br>1.收到请求后，通过请求头得到encryptAesData，RSA私钥解密后得到aeskey<br>2.通过请求体得到encryptData，然后用aeskey解密，得到明文data类型<br>3.data转换成json格式进行后续处理</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java基础-集合"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/23/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/"
    >Java基础--集合（1）</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/23/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-11-23T14:06:35.000Z" itemprop="datePublished">2020-11-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E8%AF%AD%E6%B3%95/">Java语法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java常用的集合对象一般有list，map，set和queue，它们之间的关系如下图所示：</p>
<p><img src="../../../../images/07/01.webp" alt="Image text"></p>
<p><img src="../../../../images/07/02.webp" alt="Image text"></p>
<p>可以看到：Collection是List，Set和Queue的父类，Map和Collection并列的关系。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><blockquote>
<p>Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。</p>
</blockquote>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li><p>HashMap是居于数组和链表（链表大于8时会利用红黑树）的结构。这样设计的优势在于，兼有数组的快速查找和链表的快速插入，删除元素的优势。结构如图如下：</p>
<p><img src="../../../../images/07/04.jpg" alt="Image text"></p>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; Table数组的初始化长度,2^4&#x3D;16</span><br><span class="line">    static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30; &#x2F;&#x2F;Table数组的最大长度： 1&lt;&lt;30 2^30&#x3D;1073741824</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;负载因子：默认值为0.75。 当元素的总个数&gt;当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F;链表树化阙值： 默认值为 8 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F;红黑树链化阙值： 默认值为 6 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F;最小树化阈值，当Table所有元素超过该值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</span><br><span class="line">    MIN_TREEIFY_CAPACITY &#x3D; 64</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><blockquote>
<p>链表实现时候元素节点Node，通过next来实现单链表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      final int hash;</span><br><span class="line">      final K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">      Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          this.hash &#x3D; hash;</span><br><span class="line">          this.key &#x3D; key;</span><br><span class="line">          this.value &#x3D; value;</span><br><span class="line">          this.next &#x3D; next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final K getKey()        &#123; return key; &#125;</span><br><span class="line">      public final V getValue()      &#123; return value; &#125;</span><br><span class="line">      public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">      public final int hashCode() &#123;</span><br><span class="line">          return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final V setValue(V newValue) &#123;</span><br><span class="line">          V oldValue &#x3D; value;</span><br><span class="line">          value &#x3D; newValue;</span><br><span class="line">          return oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final boolean equals(Object o) &#123;</span><br><span class="line">          if (o &#x3D;&#x3D; this)</span><br><span class="line">              return true;</span><br><span class="line">          if (o instanceof Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                  Objects.equals(value, e.getValue()))</span><br><span class="line">                  return true;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><ul>
<li>1.对key的hashCode()做hash运算，计算index;</li>
<li>2.如果没碰撞直接放到bucket⾥；</li>
<li>3.如果碰撞了，以链表的形式存在buckets后；</li>
<li>4.如果碰撞导致链表过⻓(⼤于等于TREEIFY_THRESHOLD)，就把链表转换成红⿊树(JDK1.8中的改动)；</li>
<li>5.如果节点已经存在就替换old value(保证key的唯⼀性)</li>
<li>6.如果bucket满了(超过load factor*current capacity)，就要resize</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里面，我们可以发现几个细节：</p>
<ul>
<li>bucket在进行扩容的时候，刚好是<strong>2的次幂</strong>，在做取模运算的效率⾼。</li>
<li>计算bucket的index时，p = tab[i = (n - 1) &amp; hash]) == null，这样效率会更高</li>
</ul>
<p><img src="../../../../images/06/05.jpg" alt="Image text"></p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><ul>
<li>1.对key的hashCode()做hash运算，计算index;</li>
<li>2.如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回；</li>
<li>3.如果有冲突，则通过key.equals(k)去查找对应的Entry;</li>
<li>4.若为树，则在树中通过key.equals(k)查找，O(logn)；</li>
<li>若为链表，则在链表中通过key.equals(k)查找，O(n).</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">      if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">          if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">              ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">              return first;</span><br><span class="line">          if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">              if (first instanceof TreeNode)</span><br><span class="line">                  return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              do &#123;</span><br><span class="line">                  if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                      ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                      return e;</span><br><span class="line">              &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h4><p><img src="../../../../images/07/06.webp" alt="Image text"></p>
<ul>
<li><p>特点：</p>
<ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点。</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
</li>
<li><p>链表的时间复杂度：O(n)，红黑树的时间复杂度：O(lgN)</p>
</li>
<li><p>定义：</p>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;K,<span class="title">V</span>&gt; <span class="title">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;K,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="regexp">//</span> red-black tree links 父节点</span><br><span class="line">    TreeNode&lt;K,V&gt; left;  <span class="regexp">//</span>左子树</span><br><span class="line">    TreeNode&lt;K,V&gt; right; <span class="regexp">//</span>右子树</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;  <span class="regexp">//</span> 删除后需要取消链接 needed to unlink <span class="keyword">next</span> upon deletion</span><br><span class="line">    boolean red;        <span class="regexp">//</span>颜色属性</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; <span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, <span class="keyword">next</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>我们来简单看下Collection源码结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">  int size();</span><br><span class="line">  </span><br><span class="line">  boolean isEmpty();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  boolean contains(Object o);</span><br><span class="line">  boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line"> </span><br><span class="line">  Iterator&lt;E&gt; iterator();</span><br><span class="line"></span><br><span class="line">  boolean add(E e);</span><br><span class="line">  boolean remove(Object o);</span><br><span class="line">  boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">  boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line">  </span><br><span class="line">  boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line">  </span><br><span class="line">  void clear();</span><br><span class="line">  boolean equals(Object o);</span><br><span class="line">  int hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上都是对常用方法对定义，子类必须要实现的方法。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><blockquote>
<p>Set的表现最像Collection，实际上，Set特点是<strong>不允许包含重复元素</strong>，也就是add的时候，如果是相同的元素会报异常，Set集成Collection，所以需要看Set的实现类，HashSet,LinkedHashSet,TreeSet</p>
</blockquote>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><blockquote>
<p>HashSet比较简单，内部是由HashMap来实现的，用HashMap的key作为Set的值，保证了不重复。Map此时的value是同一个new Object对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">			public HashSet() &#123;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">    	 public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/" rel="tag">Collection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-vue源码分析-项目结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/06/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"
    >vue源码分析--项目结构</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/06/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-11-06T12:04:40.000Z" itemprop="datePublished">2020-11-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-vue-axios分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/12/vue-axios%E5%88%86%E6%9E%90/"
    >vue-axios分析</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/12/vue-axios%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-10-12T08:10:41.000Z" itemprop="datePublished">2020-10-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a> / <a class="article-category-link" href="/categories/vue/adios/">adios</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是-axios？"><a href="#什么是-axios？" class="headerlink" title="什么是 axios？"></a>什么是 axios？</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>从浏览器中创建 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a></p>
</li>
<li><p>从 node.js 创建 <a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html">http</a> 请求</p>
</li>
<li><p>支持 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</p>
</li>
<li><p>拦截请求和响应</p>
</li>
<li><p>转换请求数据和响应数据</p>
</li>
<li><p>取消请求</p>
</li>
<li><p>自动转换 JSON 数据</p>
</li>
<li><p>客户端支持防御 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></p>
</li>
<li><p>是vue框架推荐使用的网络请求库</p>
</li>
</ul>
<p>Axios应用也是非常简单好用，可以查看文档 <a target="_blank" rel="noopener" href="http://www.axios-js.com/zh-cn/docs/%E3%80%82">http://www.axios-js.com/zh-cn/docs/。</a></p>
<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过阅读源码，来解读一下几个问题</p>
<ul>
<li>1.axios，Axios，instance之间是什么关系</li>
<li>拦截器的执行顺序，是如何串联起来的</li>
<li>为什么post请求时，请求参数是一个对象时，服务端接收不到传过来的参数</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>源码地址：<a target="_blank" rel="noopener" href="https://github.com/axios/axios%EF%BC%8C%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81%E9%83%BD%E5%9C%A8lib%E7%9B%AE%E5%BD%95%E4%B8%AD">https://github.com/axios/axios，主要代码都在lib目录中</a></p>
<h2 id="axios，Axios之间是什么关系"><a href="#axios，Axios之间是什么关系" class="headerlink" title="axios，Axios之间是什么关系"></a>axios，Axios之间是什么关系</h2><p>源码结构如下图示：</p>
<p><img src="../../../../images/06/wy-01.png" alt="Image text"></p>
<h3 id="axios-js"><a href="#axios-js" class="headerlink" title="axios.js"></a>axios.js</h3><ul>
<li><p>由于我们平时都是直接引入axios对象，打开axios.js源码发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.createInstance创建了axios对象</span><br><span class="line">var axios &#x3D; createInstance(defaults);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.</span><br><span class="line">function createInstance(defaultConfig) &#123;</span><br><span class="line">  var context &#x3D; new Axios(defaultConfig);</span><br><span class="line">  var instance &#x3D; bind(Axios.prototype.request, context);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Copy axios.prototype to instance</span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Copy context to instance</span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line"></span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原来axios对象是来自于Axios，从功能上来讲，axios是Axios的实例对象，因为我们可以发现Axios的requet方法，原型对象也复制了一份到axios实例上，但是从语法角度，axios 是Axios.prototype.request函数，<strong>即axios是请求request函数</strong></p>
</li>
<li><p>同时，下面是axios自己特有的属性，Axios没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Factory for creating new instances</span><br><span class="line">axios.create &#x3D; function create(instanceConfig) &#123;</span><br><span class="line">  return createInstance(mergeConfig(axios.defaults, instanceConfig));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Expose Cancel &amp; CancelToken</span><br><span class="line">axios.Cancel &#x3D; require(&#39;.&#x2F;cancel&#x2F;Cancel&#39;);</span><br><span class="line">axios.CancelToken &#x3D; require(&#39;.&#x2F;cancel&#x2F;CancelToken&#39;);</span><br><span class="line">axios.isCancel &#x3D; require(&#39;.&#x2F;cancel&#x2F;isCancel&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Expose all&#x2F;spread</span><br><span class="line">axios.all &#x3D; function all(promises) &#123;</span><br><span class="line">  return Promise.all(promises);</span><br><span class="line">&#125;;</span><br><span class="line">axios.spread &#x3D; require(&#39;.&#x2F;helpers&#x2F;spread&#39;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Axios-js"><a href="#Axios-js" class="headerlink" title="Axios.js"></a>Axios.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function Axios(instanceConfig) &#123;</span><br><span class="line">  this.defaults &#x3D; instanceConfig;</span><br><span class="line">  this.interceptors &#x3D; &#123;</span><br><span class="line">    request: new InterceptorManager(),</span><br><span class="line">    response: new InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Axios.prototype.request &#x3D; function request(config) &#123;</span><br><span class="line"> 	</span><br><span class="line">	......</span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Provide aliases for supported request methods</span><br><span class="line">utils.forEach([&#39;delete&#39;, &#39;get&#39;, &#39;head&#39;, &#39;options&#39;], function forEachMethodNoData(method) &#123;</span><br><span class="line">  &#x2F;*eslint func-names:0*&#x2F;</span><br><span class="line">  Axios.prototype[method] &#x3D; function(url, config) &#123;</span><br><span class="line">    return this.request(mergeConfig(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url,</span><br><span class="line">      data: (config || &#123;&#125;).data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.forEach([&#39;post&#39;, &#39;put&#39;, &#39;patch&#39;], function forEachMethodWithData(method) &#123;</span><br><span class="line">  &#x2F;*eslint func-names:0*&#x2F;</span><br><span class="line">  Axios.prototype[method] &#x3D; function(url, data, config) &#123;</span><br><span class="line">    return this.request(mergeConfig(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url,</span><br><span class="line">      data: data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数有默认配置接收和拦截器属性</li>
<li>requet请求和扩展的http请求的简单实现</li>
</ul>
<h2 id="拦截器的执行顺序，是如何串联起来的"><a href="#拦截器的执行顺序，是如何串联起来的" class="headerlink" title="拦截器的执行顺序，是如何串联起来的"></a>拦截器的执行顺序，是如何串联起来的</h2><h3 id="Axios-js-gt-request"><a href="#Axios-js-gt-request" class="headerlink" title="Axios.js-&gt;request"></a>Axios.js-&gt;request</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Dispatch a request</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Object&#125; config The config specific for this request (merged with this.defaults)</span><br><span class="line"> *&#x2F;</span><br><span class="line">Axios.prototype.request &#x3D; function request(config) &#123;</span><br><span class="line">  &#x2F;*eslint no-param-reassign:0*&#x2F;</span><br><span class="line">  &#x2F;&#x2F; Allow for axios(&#39;example&#x2F;url&#39;[, config]) a la fetch API</span><br><span class="line">  if (typeof config &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    config &#x3D; arguments[1] || &#123;&#125;;</span><br><span class="line">    config.url &#x3D; arguments[0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    config &#x3D; config || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  config &#x3D; mergeConfig(this.defaults, config);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Set config.method</span><br><span class="line">  if (config.method) &#123;</span><br><span class="line">    config.method &#x3D; config.method.toLowerCase();</span><br><span class="line">  &#125; else if (this.defaults.method) &#123;</span><br><span class="line">    config.method &#x3D; this.defaults.method.toLowerCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    config.method &#x3D; &#39;get&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Hook up interceptors middleware</span><br><span class="line">  var chain &#x3D; [dispatchRequest, undefined];</span><br><span class="line">  var promise &#x3D; Promise.resolve(config);</span><br><span class="line"></span><br><span class="line">  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123;</span><br><span class="line">    chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123;</span><br><span class="line">    chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  while (chain.length) &#123;</span><br><span class="line">    promise &#x3D; promise.then(chain.shift(), chain.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为axios是一个函数，执行axios也就是在执行request函数</li>
<li></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-jetpack系列-dataBinding使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/11/jetpack%E7%B3%BB%E5%88%97-dataBinding%E4%BD%BF%E7%94%A8/"
    >dataBinding使用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/11/jetpack%E7%B3%BB%E5%88%97-dataBinding%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2020-10-11T03:50:46.000Z" itemprop="datePublished">2020-10-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout&gt;</span><br><span class="line">	&lt;data&gt;</span><br><span class="line">	&lt;variable&gt;</span><br><span class="line">	&lt;&#x2F;variable&gt;</span><br><span class="line">	&lt;&#x2F;data&gt;</span><br><span class="line">	</span><br><span class="line">		&quot;@&#123;user.name&#125;&quot;&#x2F;&#x2F;简单赋值</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&quot;@&#x3D;&#123;user.name&#125;&quot;&#x2F;&#x2F;双向绑定</span><br><span class="line">		</span><br><span class="line">		&quot;@&#123;()-&gt;listenr.change()&#125;&quot;</span><br><span class="line">		</span><br><span class="line">&lt;&#x2F;layout&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kotlin:</span><br><span class="line">val binding&#x3D;DatabindingUtils.bind(this,R.layout.xxx)</span><br><span class="line">binding.user&#x3D;user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">viewmodeProvider(this,ViewModelProvider.newInstanceFacotry()).get(ViewModelXXX::class.java)</span><br><span class="line">viewmodeProvider(this,ViewModelProvider.AndroidViewModelFacotry.getInstance(application).get(ViewModelXXX::class.java)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>livedata</p>
<p>viewmodel</p>
<p>hilt</p>
<p>databinding</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-vue-cli详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/08/vue-cli%E8%AF%A6%E8%A7%A3/"
    >vue-cli详解</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/08/vue-cli%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-10-08T06:43:48.000Z" itemprop="datePublished">2020-10-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a> / <a class="article-category-link" href="/categories/vue/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote>
<p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
<ul>
<li>通过 <code>@vue/cli</code> 实现的交互式的项目脚手架。</li>
<li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 实现的零配置原型开发。</li>
<li>一个运行时依赖 <ul>
<li>可升级；</li>
<li>基于 webpack 构建，并带有合理的默认配置；</li>
<li>可以通过项目内的配置文件进行配置；</li>
<li>可以通过插件进行扩展。</li>
</ul>
</li>
<li>一个丰富的官方插件集合，集成了前端生态中最好的工具。</li>
<li>一套完全图形化的创建和管理 Vue.js 项目的用户界面。</li>
</ul>
</blockquote>
<p>简言之：vue-cli可以让我们快速初始化一个vue项目，并且封装了webpack合理的配置项，让我们可以直接进行项目开发。同时，vue-cli还提供丰富的扩展功能，甚至还有一个可视化ui界面，不仅好用，还很强大，是开发vue项目的不二之选。</p>
<h1 id="项目添加配置"><a href="#项目添加配置" class="headerlink" title="项目添加配置"></a>项目添加配置</h1><blockquote>
<p>一般而言，我们创建的项目即使不配置任何文件，也是可以正常运行的，因为vue-cli做了很多合理性的配置，但是不同的项目会有不同的需求，所以几乎都会进行自定义配置。也就是vue.config.js文件。</p>
</blockquote>
<h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。</p>
<p>这个文件应该导出一个包含了选项的对象：（这里是common.js规范）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><ul>
<li>Type: <code>string</code></li>
<li>Default: <code>&#39;/&#39;</code></li>
<li>定义部署在服务器上的子目录。例如，如果你的应用被部署在 <code>https://www.my-app.com/my-app/</code>，则设置 <code>publicPath</code> 为 <code>/my-app/</code>。</li>
<li>默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 <code>https://www.my-app.com/</code></li>
</ul>
<h3 id="oututDir"><a href="#oututDir" class="headerlink" title="oututDir"></a>oututDir</h3><ul>
<li>Type: <code>string</code></li>
<li>Default: <code>&#39;dist&#39;</code></li>
<li>当运行 <code>vue-cli-service build</code> 时生成的生产环境构建文件的目录。注意目标目录在构建之前会被清除 (构建时传入 <code>--no-clean</code> 可关闭该行为)。</li>
</ul>
<h3 id="assetsDir"><a href="#assetsDir" class="headerlink" title="assetsDir"></a>assetsDir</h3><ul>
<li><p>Type: <code>string</code></p>
</li>
<li><p>Default: <code>&#39;&#39;</code></p>
</li>
<li><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 <code>outputDir</code> 的) 目录。</p>
</li>
</ul>
<h3 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h3><ul>
<li>Type: <code>string</code></li>
<li>Default: <code>&#39;index.html&#39;</code></li>
<li>指定生成的 <code>index.html</code> 的输出路径 (相对于 <code>outputDir</code>)。也可以是一个绝对路径。</li>
</ul>
<h3 id="filenameHashing"><a href="#filenameHashing" class="headerlink" title="filenameHashing"></a>filenameHashing</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>true</code></p>
<p>默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 <code>false</code> 来关闭文件名哈希。</p>
</li>
</ul>
<h3 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h3><ul>
<li>Type: <code>boolean</code></li>
<li>Default: <code>true</code></li>
<li>如果你不需要生产环境的 source map，可以将其设置为 <code>false</code> 以加速生产环境构建。sourcemap是拿来作为定位代码debug时用的</li>
</ul>
<h3 id="css-extract"><a href="#css-extract" class="headerlink" title="css.extract"></a>css.extract</h3><ul>
<li><p>Type: <code>boolean | Object</code></p>
</li>
<li><p>Default: 生产环境下是 <code>true</code>，开发环境下是 <code>false</code></p>
<p>是否将组件中的 CSS 提取至一个独立的 CSS 文件中 (而不是动态注入到 JavaScript 中的 inline 代码)。</p>
<p>是通过mini-css-extract-plugin来实现的</p>
</li>
</ul>
<h3 id="css-sourceMap"><a href="#css-sourceMap" class="headerlink" title="css.sourceMap"></a>css.sourceMap</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>false</code></p>
<p>是否为 CSS 开启 source map。设置为 <code>true</code> 之后可能会影响构建的性能。</p>
</li>
</ul>
<h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><ul>
<li><p>Type: <code>Object</code></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/dev-server/">所有 <code>webpack-dev-server</code> 的选项</a>都支持。注意：</p>
<ul>
<li>有些值像 <code>host</code>、<code>port</code> 和 <code>https</code> 可能会被命令行参数覆写。</li>
<li>有些值像 <code>publicPath</code> 和 <code>historyApiFallback</code> 不应该被修改，因为它们需要和开发服务器的 <a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/config/#publicpath">publicPath</a> 同步以保障正常的工作。</li>
</ul>
</li>
</ul>
<h3 id="configureWebpack"><a href="#configureWebpack" class="headerlink" title="configureWebpack"></a>configureWebpack</h3><ul>
<li><p>Type: <code>Object | Function</code></p>
<p>如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。</p>
<p>如果这个值是一个函数，则会接收被解析的配置作为参数。该函数既可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。</p>
</li>
</ul>
<h3 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h3><ul>
<li><p>Type: <code>Function</code></p>
<p>是一个函数，会接收一个基于 webpack-chain的 <code>ChainableConfig</code> 实例。允许对内部的 webpack 配置进行更细粒度的修改。</p>
</li>
</ul>
<h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const Timestamp &#x3D; new Date().getTime();</span><br><span class="line">const CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;);</span><br><span class="line">const productionGzipExtensions &#x3D; [&quot;js&quot;, &quot;css&quot;];</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 生产环境 sourceMap</span><br><span class="line">    productionSourceMap: false,</span><br><span class="line">    &#x2F;&#x2F; 配置线上访问的前置目录</span><br><span class="line">    publicPath: &#39;&#x2F;mp&#x2F;&#39;,</span><br><span class="line">    &#x2F;&#x2F; 打包的文件夹名</span><br><span class="line">    outputDir: &#39;mp&#39;,</span><br><span class="line">    &#x2F;&#x2F; 放置生成的静态资源js css img的文件夹</span><br><span class="line">    assetsDir: &#39;static&#39;,</span><br><span class="line">    &#x2F;&#x2F; 指定生成的html入口文件路径</span><br><span class="line">    indexPath: &#39;index.html&#39;,</span><br><span class="line">    &#x2F;&#x2F;生成的静态资源在它们的文件名中是否包含hash以便更好的控制缓存</span><br><span class="line">    filenameHashing: true,</span><br><span class="line">    css: &#123;</span><br><span class="line">        sourceMap: true &#x2F;&#x2F;打开本地开发环境下的sourceMap</span><br><span class="line">    &#125;,</span><br><span class="line">    chainWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(&#39;vue$&#39;, &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;)</span><br><span class="line">            .set(&#39;@&#39;, path.join(__dirname, &#39;src&#39;))   &#x2F;&#x2F;项目别名设置</span><br><span class="line">            .set(&#39;@pages&#39;, path.join(__dirname, &#39;src&#x2F;pages&#39;))</span><br><span class="line">            .set(&#39;@assets&#39;, path.join(__dirname, &#39;src&#x2F;assets&#39;))</span><br><span class="line">            .set(&#39;@components&#39;, path.join(__dirname, &#39;src&#x2F;components&#39;))</span><br><span class="line">            .set(&#39;@store&#39;, path.join(__dirname, &#39;src&#x2F;store&#39;))</span><br><span class="line">            .set(&#39;@utils&#39;, path.join(__dirname, &#39;src&#x2F;utils&#39;))</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;打包分析工具</span><br><span class="line">        if (process.env.use_analyzer) &#123;</span><br><span class="line">            config</span><br><span class="line">                .plugin(&#39;webpack-bundle-analyzer&#39;)</span><br><span class="line">                .use(require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">        config.externals &#x3D; &#123;</span><br><span class="line">            vue: &#39;Vue&#39;,</span><br><span class="line">            moment: &#39;moment&#39;,</span><br><span class="line">            lodash: &#39;_&#39;,</span><br><span class="line">            &#39;vue-router&#39;: &#39;VueRouter&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; js打包版本控制</span><br><span class="line">        config.output.filename &#x3D; &#96;static&#x2F;js&#x2F;[name].[hash:8].$&#123;Timestamp&#125;.js&#96;,</span><br><span class="line">        config.output.chunkFilename &#x3D; &#96;static&#x2F;js&#x2F;[name].[hash:8].$&#123;Timestamp&#125;.js&#96;,</span><br><span class="line">        &#x2F;&#x2F; Gzip压缩</span><br><span class="line">        config.plugins.push(new CompressionWebpackPlugin(&#123;</span><br><span class="line">            filename: &quot;[path].gz[query]&quot;,</span><br><span class="line">            algorithm: &#39;gzip&#39;,</span><br><span class="line">            test: new RegExp(&quot;\\.(&quot; + productionGzipExtensions.join(&quot;|&quot;) + &quot;)$&quot;), &#x2F;&#x2F;匹配文件名</span><br><span class="line">            threshold: 10240,</span><br><span class="line">            minRatio: 0.8,</span><br><span class="line">            deleteOriginalAssets: false &#x2F;&#x2F;是否删除源文件(默认)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: 8088,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &#39;&#x2F;xxx&#x2F;api&#39;: &#123;</span><br><span class="line">                target: &#39;http:&#x2F;&#x2F;api.xxx.cn&#x2F;xxx&#x2F;api&#39;,</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                ws: true,&#x2F;&#x2F;websocket</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    &#39;^&#x2F;xxx&#x2F;api&#39;: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue-cli/" rel="tag">vue-cli</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-webpack详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/07/webpack%E8%AF%A6%E8%A7%A3/"
    >webpack详解</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/07/webpack%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-10-07T14:53:21.000Z" itemprop="datePublished">2020-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a> / <a class="article-category-link" href="/categories/vue/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p><em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em></p>
</blockquote>
<p><img src="../../../../images/05/wy-01.png" alt="Image text"></p>
<p>如图所示，通过webpack可以对我们的项目源码通过我们的配置做各种各样的处理，最后会得到一系列可以放在服务器运行的文件。</p>
<p>很多时候，我们都是先接触vue再慢慢接触到webpack等概念的，首先我们需要明确的是，vue框架用到了webpack，webpack不仅仅是服务于vue框架的，它是服务于整个前端工程化开发的，包括我们的react等各种框架，都可以用webpack来做项目的模块化打包。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>webpack默认的配置文件是webpack.config.js</li>
<li>可以通过 <u>webpack –config 指定配置文件</u> 来修改默认配置文件</li>
</ul>
<h2 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.打包的入口文件，默认是下面配置</span><br><span class="line">	entry:&#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">	&#x2F;&#x2F;2.打包的输出，默认是下面配置</span><br><span class="line">	output:&#123;</span><br><span class="line">    path: &#39;.&#x2F;dist&#39;,</span><br><span class="line">    filename: &#39;main.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">	&#x2F;&#x2F;3.环境</span><br><span class="line">	mode:&#39;production&#39;,</span><br><span class="line">	&#x2F;&#x2F;4.loader模块</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;test:&#39;&#x2F;\.txt$&#x2F;&#39;,use:&#39;raw-loader&#39;&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	&#x2F;&#x2F;5.插件配置</span><br><span class="line">	plugins:[</span><br><span class="line">		new HtmlwebpackPlugin(&#123;</span><br><span class="line">			template:&#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack有四个<strong>核心概念</strong>：</p>
<ul>
<li>入口(entry)</li>
<li>输出(output)</li>
<li>loader</li>
<li>插件(plugins)</li>
</ul>
<h2 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h2><ul>
<li><p>1.安装node和npm</p>
<ul>
<li><p>直接下载node安装即可，npm内置在node包中，会同步安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">可以查看版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过npm安装webpack和webpak-cli</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;建议局部安装，所以先创建一个项目</span><br><span class="line">mkdir mywebpack</span><br><span class="line">&#x2F;&#x2F;进入到项目中</span><br><span class="line">cd mywebpack</span><br><span class="line">&#x2F;&#x2F;初始化npm</span><br><span class="line">npm init -y</span><br><span class="line">&#x2F;&#x2F;安装局部的webpack和webpack-cli（4.0以上版本需要单独安装cli）</span><br><span class="line">npm install webpack webpack-cli --save-dev</span><br><span class="line">&#x2F;&#x2F;查看是否安装成功</span><br><span class="line">.&#x2F;node_modules&#x2F;.bin&#x2F;webpack -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>官方文档也是提醒进行局部安装</p>
</li>
</ul>
</li>
</ul>
<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p><img src="../../../../images/05/wy-02.png" alt="Image text"></p>
<p>通过上面安装和项目创建，我们可以生成类似如上图所示的项目</p>
<ul>
<li><p>1.新建webpack.config.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;) &#x2F;&#x2F;path是node中的核心库，用来组成文件路径</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.打包的入口文件，默认是下面配置</span><br><span class="line">	entry:&#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">	&#x2F;&#x2F;2.打包的输出，默认是下面配置</span><br><span class="line">  output:&#123;</span><br><span class="line">    path: path.join(__dirname,&#39;dist&#39;),</span><br><span class="line">    filename: &#39;main.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">	&#x2F;&#x2F;3.环境</span><br><span class="line">	mode:&#39;production&#39;,</span><br><span class="line">	&#x2F;&#x2F;4.loader模块</span><br><span class="line">	module:&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;,</span><br><span class="line">	&#x2F;&#x2F;5.插件配置</span><br><span class="line">	plugins:[</span><br><span class="line">	</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.配置package.json脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpacktest&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;:&quot;webpack&quot;   &#x2F;&#x2F;该脚本会自动寻找.&#x2F;node_modules&#x2F;.bin&#x2F;webpack</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.44.2&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.12&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.新建src目录和入口index.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;简单输出一个文本内容</span><br><span class="line">document.write(&#39;hello webpack&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.新建页面文件index.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;..&#x2F;dist&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，引用了dist/main.js文件，此时，该文件还没有生成，需要我们通过webpack来执行生成该文件</p>
</li>
<li><p>5.打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build  &#x2F;&#x2F;这里执行的就是npm的package.json中的脚本build</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.浏览器打开index.html，就可以看到输出的内容</p>
</li>
</ul>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="入口entry"><a href="#入口entry" class="headerlink" title="入口entry"></a>入口entry</h2><blockquote>
<ul>
<li>用来指定项目的打包入口</li>
<li>单入口：entry是一个字符串</li>
<li>多入口：entry是一个对象</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.单页面</span><br><span class="line">	entry:&#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出 output"></a>输出 output</h2><blockquote>
<ul>
<li>用来指定打包输出文件</li>
<li>output对应的是一个对象，有path和filename两个属性</li>
<li>path：打包路径</li>
<li>filename：打包出来的文件名称</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		path:path.join(__dirname,&#39;dist&#39;),&#x2F;&#x2F;通过node中的path来制定路径</span><br><span class="line">		filename:&#39;[name].js&#39; &#x2F;&#x2F;通过占位符name来兼容多页面入口</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h2><blockquote>
<ul>
<li>webpack原生只支持js和json文件类型，通过loaders可以去支持其他类型的文件并且转化为有效的模块添加到依赖图中</li>
<li>本身是一个函数，通过接收源文件作为参数，返回转换的结果</li>
<li>对一个对象</li>
</ul>
</blockquote>
<h3 id="常用的loaders"><a href="#常用的loaders" class="headerlink" title="常用的loaders"></a>常用的loaders</h3><p><img src="../../../../images/05/wy-03.png" alt="Image text"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		path:path.join(__dirname,&#39;dist&#39;),&#x2F;&#x2F;通过node中的path来制定路径</span><br><span class="line">		filename:&#39;[name].js&#39; &#x2F;&#x2F;通过占位符name来兼容多页面入口</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;test:&#39;&#x2F;\.txt$&#x2F;&#39;,use:&#39;raw-loader&#39;&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ul>
<li>test：指定匹配规则，正则</li>
<li>use：该规则下，使用哪种加载器</li>
</ul>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><blockquote>
<ul>
<li>插件是用于bundle文件的优化，资源管理和环境变量的注入</li>
<li>插件是可以作用于整个构建过程</li>
<li>是个数组对象</li>
</ul>
</blockquote>
<h3 id="常有plugins"><a href="#常有plugins" class="headerlink" title="常有plugins"></a>常有plugins</h3><p><img src="../../../../images/05/wy-04.png" alt="Image text"></p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		path:path.join(__dirname,&#39;dist&#39;),&#x2F;&#x2F;通过node中的path来制定路径</span><br><span class="line">		filename:&#39;[name].js&#39; &#x2F;&#x2F;通过占位符name来兼容多页面入口</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;test:&#39;&#x2F;\.txt$&#x2F;&#39;,use:&#39;raw-loader&#39;&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		&#x2F;&#x2F;直接将插件放到数组中</span><br><span class="line">		new HtmlWebpackPlugin(&#123;templete:&#39;.&#x2F;src&#x2F;index.html&#39;&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><blockquote>
<ul>
<li>webpack4之后才提出来的概念</li>
<li>用来指定当前的构建环境是production，development还是none</li>
<li>设置mode可以默认使用webpack内置的函数，默认值是production</li>
</ul>
</blockquote>
<p><img src="../../../../images/05/wy-05.png" alt="Image text"></p>
<h1 id="loader应用"><a href="#loader应用" class="headerlink" title="loader应用"></a>loader应用</h1><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><ul>
<li><p>作用：将es6语法转为es5语法</p>
</li>
<li><p>本地安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;i是install缩写。 -D是--save-dev缩写</span><br><span class="line">npm i @babel&#x2F;core @babel&#x2F;preset-env babel-loader -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目中新建.babelrc文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;:[</span><br><span class="line">    &quot;@babel&#x2F;preset-env&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack.config.js文件添加loader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;.js$&#x2F;,</span><br><span class="line">      use: &#39;babel-loader&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解析css"><a href="#解析css" class="headerlink" title="解析css"></a>解析css</h2><blockquote>
<ul>
<li>css-loader：用于加载.css文件，并且转化为commonjs对象</li>
<li>style-loader：将样式通过style标签插入到head中</li>
</ul>
</blockquote>
<ul>
<li>本地安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-loader style-loader -D</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件配置</p>
<p>这里注意，对于同个文件需要多个loader来处理时，需要使用数组，并且此时loader是从右到左来执行</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;.js$&#x2F;,</span><br><span class="line">      use: &#39;babel-loader&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;.css$&#x2F;,</span><br><span class="line">      use: [&#39;style-loader&#39;,</span><br><span class="line">        &#39;css-loader&#39;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><blockquote>
<ul>
<li>less</li>
<li>Less-loader</li>
</ul>
</blockquote>
<ul>
<li>本地安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less less-loader -D</span><br></pre></td></tr></table></figure>

<ul>
<li>文件配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     test: &#x2F;.less$&#x2F;,</span><br><span class="line">     use: [&#39;style-loader&#39;,</span><br><span class="line">       &#39;css-loader&#39;,</span><br><span class="line">       &#39;less-loader&#39;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片-字体"><a href="#图片-字体" class="headerlink" title="图片/字体"></a>图片/字体</h2><blockquote>
<p>file-loader</p>
</blockquote>
<ul>
<li>本地安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i file-loader -D</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     test: &#x2F;(jpg|jpeg|png|gif|svg)$&#x2F;,</span><br><span class="line">     use:&#39;file-loader&#39;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h1 id="plugins应用"><a href="#plugins应用" class="headerlink" title="plugins应用"></a>plugins应用</h1><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>配置，该插件是webpack自带的，所以引入即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">  &#x2F;&#x2F;3.环境</span><br><span class="line"> mode: &#39;dev&#39;,</span><br><span class="line"> &#x2F;&#x2F;5.插件配置</span><br><span class="line"> plugins: [</span><br><span class="line">   new webpack.HotModuleReplacementPlugin()</span><br><span class="line"> ],</span><br><span class="line"> devServe:&#123;</span><br><span class="line">   contentBase:&#39;.&#x2F;dist&#39;,</span><br><span class="line">   hot:true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>package.json配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;watch&quot;:&quot;webpack --watch&quot;,</span><br><span class="line">  &quot;dev&quot;:&quot;webpack-dev-serve --open&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="CSS文件压缩"><a href="#CSS文件压缩" class="headerlink" title="CSS文件压缩"></a>CSS文件压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.先npm安装插件</span><br><span class="line">var OptimizeCSSAssetsPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">   	assetNameRegExp:&#x2F;\.css$&#x2F;g,</span><br><span class="line">   	cssProcessor:require(&#39;cssnano&#39;)</span><br><span class="line">   &#125;)</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure>

<h2 id="HTML-JS文件压缩"><a href="#HTML-JS文件压缩" class="headerlink" title="HTML/JS文件压缩"></a>HTML/JS文件压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先npm安装</span><br><span class="line">var HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line"> plugins: [</span><br><span class="line"> 		&#x2F;&#x2F;如果是多页面应用，需要为每个页面配置HtmlWebpackPlugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">    	templete:path.join(__dirname,&#39;src&#x2F;index.html&#39;),</span><br><span class="line">    	filename:&#39;index.html&#39;,</span><br><span class="line">    	chunks:[&#39;index&#39;],</span><br><span class="line">    	inject:true,</span><br><span class="line">    	minify:&#123;</span><br><span class="line">    		html5:true,</span><br><span class="line">    		collapseWhitespace:true,</span><br><span class="line">    		preserveLineBreaks:false,</span><br><span class="line">    		minifyCSS:true,</span><br><span class="line">    		minifyJS:true,</span><br><span class="line">    		removeComments:false</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>

<h2 id="自动清除构建目录"><a href="#自动清除构建目录" class="headerlink" title="自动清除构建目录"></a>自动清除构建目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.先npm安装插件</span><br><span class="line">var CleanWebpackPlugin &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new CleanWebpackPlugin()</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure>

<h1 id="postCSS"><a href="#postCSS" class="headerlink" title="postCSS"></a>postCSS</h1><p>postcss 一种对css编译的工具，类似babel对js的处理，常见的功能如：</p>
<p>1 . 使用下一代css语法</p>
<p>2 . 自动补全浏览器前缀</p>
<p>3 . 自动把px代为转换成rem</p>
<p>4 . css 代码压缩等等</p>
<p>postcss 只是一个工具，本身不会对css一顿操作，它通过插件实现功能，autoprefixer 就是其一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;postcss.config.js</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;1.css自动添加前缀</span><br><span class="line">npm i postcss-loader autoprefixer postcss-cssnext postcss-pxtorem -D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:&#x2F;\.css$&#x2F;g,</span><br><span class="line">			exclude:&#x2F;node_modules&#x2F;,</span><br><span class="line">			use:[</span><br><span class="line">				&#123;loader:&#39;style-loader&#39;&#125;,</span><br><span class="line">				&#123;loader:&#39;css-loader&#39;,options:&#123;</span><br><span class="line">					importLoaders:1</span><br><span class="line">				&#125;&#125;,</span><br><span class="line">				&#123;loader:&#39;postcss-loader&#39;&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &#39;autoprefixer&#39;: &#123;</span><br><span class="line">      overrideBrowserslist: [</span><br><span class="line">        &quot;Android 4.1&quot;,</span><br><span class="line">        &quot;iOS 7.1&quot;,</span><br><span class="line">        &quot;Chrome &gt; 31&quot;,</span><br><span class="line">        &quot;ff &gt; 31&quot;,</span><br><span class="line">        &quot;ie &gt;&#x3D; 8&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;postcss-pxtorem&#39;: &#123;</span><br><span class="line">      rootValue: 75, &#x2F;&#x2F;在html节点设置的font-size大小</span><br><span class="line">      unitPrecision:5,&#x2F;&#x2F;转rem小数点位数</span><br><span class="line">      propList: [&#39;*&#39;],	&#x2F;&#x2F;指定转成rem的属性，比如font-size,*表示全部</span><br><span class="line">      mediaQuery:false,&#x2F;&#x2F;媒体查询时是否转化</span><br><span class="line">      minPixelValue:0,&#x2F;&#x2F;小于多少px不转为rem</span><br><span class="line">      selectorBlackList:[&#39;.van&#39;]</span><br><span class="line">      &#x2F;&#x2F;特殊技巧:不转换成rem，px检测区分大小写，也就是说Px&#x2F;PX&#x2F;pX不会被转换，可以用这个方式避免转换成rem</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="font-size适配"><a href="#font-size适配" class="headerlink" title="font-size适配"></a>font-size适配</h2><ul>
<li>1.postcss-pxtorem</li>
<li>2.结合lib-flexible.js（根据rem动态计算font-size单位）</li>
</ul>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="文件指纹hash"><a href="#文件指纹hash" class="headerlink" title="文件指纹hash"></a>文件指纹hash</h2><blockquote>
<ul>
<li>Hash：只有项目中有文件变动了，hash值就会变化</li>
<li>chunkhash：和webpack打包的chunk有关，不同的entry会生成不同的chunkhash值</li>
<li>contenthash：根据文件内容来定义hash，只有文件内容有变动，hash就会变化</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		path:path.join(__dirname,&#39;dist&#39;),&#x2F;&#x2F;通过node中的path来制定路径</span><br><span class="line">		&#x2F;&#x2F;js文件用chunkhash</span><br><span class="line">		filename:&#39;[name][chunkhash:8].js&#39; &#x2F;&#x2F;通过占位符name来兼容多页面入口</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#x2F;&#x2F;文件图片用hash</span><br><span class="line">			&#123;test:&#39;&#x2F;\.(png|jpeg|jpg|gif)$&#x2F;&#39;,use:[</span><br><span class="line">				&#123;loader:&quot;file-loader&quot;,</span><br><span class="line">				options:&#123;</span><br><span class="line">					name:[name][hash:8].[ext]</span><br><span class="line">				&#125;&#125;</span><br><span class="line">			]&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		&#x2F;&#x2F;css文件用contenthash</span><br><span class="line">		new MiniCssExtractPlugin(&#123;</span><br><span class="line">			filename:&#96;[name][contenthash:8].css&#96;</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p><img src="../../../../images/05/wy-06.png" alt="Image text"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-V8引擎内存模型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/30/V8%E5%BC%95%E6%93%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"
    >V8引擎内存模型</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/09/30/V8%E5%BC%95%E6%93%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2020-09-30T06:35:19.000Z" itemprop="datePublished">2020-09-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><h3 id="JavaScript是什么类型的语言"><a href="#JavaScript是什么类型的语言" class="headerlink" title="JavaScript是什么类型的语言"></a>JavaScript是什么类型的语言</h3><p>每种编程语言都有内建的数据模型，但它们的数据类型常有不同之处，使用方式也有不同。比如C，Java在使用变量之前，先要申明好数据类型，比如如下C代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int a &#x3D; 1;</span><br><span class="line">   char* b &#x3D; &quot; 极客时间 &quot;;</span><br><span class="line">   bool c &#x3D; true;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为<strong>静态语言。</strong></p>
<p>相反地，我们把在运行过程中需要检查数据类型的语言称为<strong>动态语言</strong>。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>
<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a</span><br></pre></td></tr></table></figure>

<p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，<strong>C 编译器会把 int 型的变量悄悄转换为 bool 型的变量</strong>，我们通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。</p>
<p>对于各种语言的类型，你可以参考下图</p>
<p><img src="../../../../images/04/wy-01.png" alt="Image text"></p>
<h3 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h3><p>现在我们知道了，JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？</p>
<ul>
<li><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>
<li><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据</li>
</ul>
<p>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar</span><br><span class="line">bar = <span class="number">12</span> </span><br><span class="line">bar = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">bar = <span class="literal">true</span></span><br><span class="line">bar = <span class="literal">null</span></span><br><span class="line">bar = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p>
<p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用“typeof”运算符。具体使用方式如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar)  <span class="comment">//undefined</span></span><br><span class="line">bar = <span class="number">12</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar) <span class="comment">//number</span></span><br><span class="line">bar = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar)<span class="comment">//string</span></span><br><span class="line">bar = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar) <span class="comment">//boolean</span></span><br><span class="line">bar = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar) <span class="comment">//object</span></span><br><span class="line">bar = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar) <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p>
<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>
<p><img src="../../../../images/04/wy-02.png" alt="Image text"></p>
<p>了解这些类型之后，还有三点需要你注意一下。</p>
<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>
<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  name:<span class="string">&#x27;极客时间&#x27;</span>,</span><br><span class="line">  update:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p>
<p>第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>
<h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>JS的内存分布也比较简单，如图示：</p>
<p><img src="../../../../images/04/wy-03.png" alt="Image text"></p>
<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。</p>
<p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p>
<h3 id="栈和堆-1"><a href="#栈和堆-1" class="headerlink" title="栈和堆"></a>栈和堆</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    <span class="keyword">var</span> c = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> d = c</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。</p>
<p><img src="../../../../images/04/wy-04.png" alt="Image text"></p>
<p>可以看到，普通变量是直接存储在执行上下文中，但是对象变量执行上下文中存储的是堆中的一个内存地址，实际存储该变量的内存空间是堆。</p>
<p>也就是说：</p>
<p>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p>
<p><strong>答案是不可以的。</strong>这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>
<p><img src="../../../../images/04/wy-05.png" alt="Image text"></p>
<h3 id="闭包的内存模型"><a href="#闭包的内存模型" class="headerlink" title="闭包的内存模型"></a>闭包的内存模型</h3><p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123; </span><br><span class="line">        setName:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;,</span><br><span class="line">        getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot; 极客邦 &quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>简单分析下上述代码的内存模型</p>
<ul>
<li>先创建一个全局的执行上下文，存储有变量函数foo，指向储存函数代码的地址</li>
<li>执行foo函数，创建foo的执行上下文</li>
<li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo - 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li>
<li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</li>
<li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中</li>
</ul>
<p>通过上面的分析，我们可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：</p>
<p><img src="../../../../images/04/wy-06.png" alt="Image text"></p>
<p>当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。</p>
<p>总的来说，产生闭包的核心有两步：</p>
<ul>
<li><p>第一步是需要预扫描内部函数；</p>
</li>
<li><p>第二步是把内部函数引用的外部变量保存到堆中。</p>
</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="调用栈中内存回收"><a href="#调用栈中内存回收" class="headerlink" title="调用栈中内存回收"></a>调用栈中内存回收</h3><p>调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>
<p><img src="../../../../images/04/wy-07.png" alt="Image text"></p>
<p>执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个<strong>记录当前执行状态的指针</strong>（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>
<p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。</p>
<p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图</p>
<p><img src="../../../../images/04/wy-08.png" alt="Image text"></p>
<p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>
<p>所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p>
<h3 id="堆中内存回收"><a href="#堆中内存回收" class="headerlink" title="堆中内存回收"></a>堆中内存回收</h3><p>在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>
<p>一般有两个回收器，分别为：新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）</p>
<p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>
<ul>
<li>副垃圾回收器，主要负责新生代的垃圾回收。</li>
<li>主垃圾回收器，主要负责老生代的垃圾回收。</li>
</ul>
<p><img src="../../../../images/04/wy-09.png" alt="Image text"></p>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><ul>
<li>新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域</li>
<li>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</li>
<li>垃圾清理的过程中，会先对对象做标记，标记完成后，进行垃圾清理阶段，同时生下来的对象会有序的复制到空闲区域中，清空对象区域，然后对象区域和空闲区域进行角色反转。</li>
<li>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</li>
<li>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</li>
</ul>
<h4 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h4><p>除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，</p>
<ul>
<li><p>一个是对象占用空间大，</p>
</li>
<li><p>一个是对象存活时间长。</p>
</li>
</ul>
<p>主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的</p>
<ul>
<li>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</li>
<li>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</li>
</ul>
<p><img src="../../../../images/04/wy-10.png" alt="Image text"></p>
<ul>
<li>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图</li>
</ul>
<p><img src="../../../../images/04/wy-11.png" alt="Image text"></p>
<h3 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h3><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p>
<p><img src="../../../../images/04/wy-12.png" alt="Image text"></p>
<p>为了改变这种垃圾回收造成明显性的页面卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：</p>
<p><img src="../../../../images/04/wy-13.png" alt="Image text"></p>
<h2 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h2><p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>
<p>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</p>
<p>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p>
<p>那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图</p>
<p><img src="../../../../images/04/wy-14.png" alt="Image text"></p>
<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>
<ol>
<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</li>
<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>
</ol>
<h3 id="V8是如何执行一段代码的"><a href="#V8是如何执行一段代码的" class="headerlink" title="V8是如何执行一段代码的"></a>V8是如何执行一段代码的</h3><p><img src="../../../../images/04/wy-15.png" alt="Image text"></p>
<p>从图中可以清楚地看到，V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan，那么它们是如何配合去执行一段 JavaScript 代码的呢? 下面我们就按照上图来一一分解其执行流程。</p>
<p><strong>1. 生成抽象语法树（AST）和执行上下文</strong></p>
<p>将源代码转换为抽象语法树，并生成执行上下文，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p>
<p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p>
<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>
<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line">myName = <span class="string">&quot;geektime&quot;</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>这段代码经过javascript-ast站点处理后，生成的 AST 结构如下：</p>
<p><img src="../../../../images/04/wy-16.png" alt="Image text"></p>
<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>
<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>
<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>
<p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p>
<p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>
<p><img src="../../../../images/04/wy-17.png" alt="Image text"></p>
<p>从图中可以看出，通过var myName = “极客时间”简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p>
<p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
<p>这就是 AST 的生成过程，先分词，再解析。</p>
<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p>
<p><strong>2. 生成字节码</strong></p>
<p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>
<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>
<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>
<p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>
<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图</p>
<p><img src="../../../../images/04/wy-18.png" alt="Image text"></p>
<p><strong>3. 执行代码</strong></p>
<p>生成字节码之后，接下来就要进入执行阶段了。</p>
<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。<strong>在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，</strong>然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>
<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</p>
<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>
<p>对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>
<p>这么多语言的工作引擎都使用了“字节码 +JIT”技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>
<p><img src="../../../../images/04/wy-19.png" alt="Image text"></p>
<h3 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h3><p>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>
<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容</p>
<ul>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/V8/" rel="tag">V8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="tag">内存模型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-浏览器的事件循环机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"
    >浏览器的事件循环机制</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/09/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-09-29T03:34:39.000Z" itemprop="datePublished">2020-09-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="早期消息队列"><a href="#早期消息队列" class="headerlink" title="早期消息队列"></a>早期消息队列</h1><p>下图模拟早期消息队列机制</p>
<p><img src="../../../../images/03/wy-01.png" alt="Image text"></p>
<ul>
<li><p>内部维护栈结构的一个消息队列</p>
</li>
<li><p>IO线程会把渲染进程中的资源加载完成消息，点击消息和其他事件消息添加到消息队列中，同时与其他进程的交换消息也是通过IO线程来交互</p>
</li>
<li><p>渲染主线程通过无限循环不断取消息队列里面需要处理的消息</p>
</li>
</ul>
<h2 id="单线程页面缺点"><a href="#单线程页面缺点" class="headerlink" title="单线程页面缺点"></a>单线程页面缺点</h2><p>通过上图可以看到，页面线程所以执行的任务都来自于消息队列。消息队列是FIFO(先进先出)的属性，也就是说放入队列里面的任务，需要等待前面的任务执行完后才会执行。鉴于这个属性，就有如下两个问题需要解决：</p>
<ul>
<li>如何处理高优先级任务</li>
</ul>
<p>比如典型的场景就是监控DOM节点的变化（节点的插入，修改，删除等动态变化），然后根据这些变化进行相应的业务逻辑。由于是单队列任务栈，后来的消息任务只能等待前面的任务执行完后才会执行，无法进行高优先级相应。</p>
<ul>
<li>单个任务耗时</li>
</ul>
<p>在消息队列中，如果某个执行任务非常耗时，那么其后面的任务时间会一直无法执行，从而会让页面有卡顿等现象发生。</p>
<h1 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>页面中大部分<strong>任务</strong>都是在主线程上完成的，大致包括：</p>
<ul>
<li>渲染事件（如解析DOM，计算布局，绘制）</li>
<li>用户交互事件（鼠标点击，页面滑动，放大缩小）</li>
<li>JavaScript脚本执行事件</li>
<li>网络请求完成，文件读写完成事件</li>
</ul>
<p><strong>一定得记住，这里的任务并不是JavaScript中某个具体的函数，而是执行整个JS代码算一个任务</strong></p>
<p>为了协调这些任务有条不紊的在主线程中执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟消息队列（异步）和普通消息队列（同步）。然后主线程采用一个for循环，不断的从这些任务队列中取出任务并执行。我们把这些队列中的任务称为宏任务</p>
<p>下面C代码简单展示该逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessTimerTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 从 delayed_incoming_queue 中取出已经到期的定时器任务</span></span><br><span class="line">  <span class="comment">// 依次执行这些任务</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">TaskQueue task_queue；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessTask</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">bool</span> keep_running = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainTherad</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行同步队列任务，</span></span><br><span class="line">    Task task = task_queue.takeTask();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行异步队列任务</span></span><br><span class="line">    ProcessTask(task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行延迟队列中的任务</span></span><br><span class="line">    ProcessDelayTask()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!keep_running) <span class="comment">// 如果设置了退出标志，那么直接退出线程循环</span></span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在for循环中，会执行同步队列任务，等这里面的任务队列都执行完毕后，再取异步任务队列任务，比如setTimeOut的回调代码就是在该任务中。</p>
<h2 id="setTimeOut"><a href="#setTimeOut" class="headerlink" title="setTimeOut"></a>setTimeOut</h2><p>有必要简单分析一下setTimeOut实现原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function showName()&#123;</span><br><span class="line">  console.log(&quot; 极客时间 &quot;)</span><br><span class="line">&#125;</span><br><span class="line">var timerID &#x3D; setTimeout(showName,200);</span><br></pre></td></tr></table></figure>

<p>上面代码是：200毫秒后打印“极客时间”</p>
<p>实际上，JavaScript调用setTimeOut设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct DelayTask&#123;</span><br><span class="line">  int64 id；</span><br><span class="line">  CallBackFunction cbf;</span><br><span class="line">  int start_time;</span><br><span class="line">  int delay_time;</span><br><span class="line">&#125;;</span><br><span class="line">DelayTask timerTask;</span><br><span class="line">timerTask.cbf = showName;</span><br><span class="line">timerTask.start_time = getCurrentTime(); // 获取当前时间</span><br><span class="line">timerTask.delay_time = 200;// 设置延迟执行时间</span><br></pre></td></tr></table></figure>

<p>创建好回调任务之后，再将该任务添加到延迟执行队列中</p>
<p>执行 ProcessDelayTask 函数会根据发起时间和延迟时间<strong>计算出到期的任务</strong>，然后依次执行这些<strong>到期的任务</strong>。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p>
<p>但是，异步任务必须等待同步任务执行完成才会执行，所以异步队列任务的时效性就得不到保证</p>
<h1 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h1><p><strong>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务</strong></p>
<p><strong>微任务</strong>就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>
<p>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为<strong>在当前宏任务执行的过程中，有时候会产生多个微任务</strong>，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</p>
<h2 id="微任务如何产生的"><a href="#微任务如何产生的" class="headerlink" title="微任务如何产生的"></a>微任务如何产生的</h2><p>微任务产生有两种时机：</p>
<ul>
<li>1.使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li>
<li>2.使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</li>
</ul>
<h2 id="何时被执行"><a href="#何时被执行" class="headerlink" title="何时被执行"></a>何时被执行</h2><ul>
<li>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。</li>
<li>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</li>
<li>参考下面的示意图</li>
</ul>
<p><img src="../../../../images/03/wy-02.png" alt="Image text"></p>
<p><img src="../../../../images/03/wy-02.png" alt="Image text"></p>
<p>该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p>
<p>在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p>
<p>以上就是微任务的工作流程，从上面分析我们可以得出如下几个结论：</p>
<ul>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>
<li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以-你在写代码的时候一定要注意控制微任务的执行时长。</li>
<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/V8/" rel="tag">V8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" rel="tag">事件循环机制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-浏览器中JavaScript的执行机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%ADJavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"
    >浏览器中JavaScript的执行机制</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%ADJavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-09-27T13:21:01.000Z" itemprop="datePublished">2020-09-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><h2 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h2><p>JavaScript中，var变量声明会有一个顺序上的提升</p>
<p>比如我们的属性变量：</p>
<p><img src="../../../../images/02/wy-01.png" alt="Image text"></p>
<p>再比如我们的函数变量：</p>
<p><img src="../../../../images/02/wy-02.png" alt="Image text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname &#x3D; &#39;极客时间&#39;</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&#39;函数showName被执行&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过变量提升后，实际的顺序为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myname&#x3D;undefined</span><br><span class="line">function showName()&#123;</span><br><span class="line">		console.log(&#39;函数showName被执行&#39;);</span><br><span class="line">&#125;</span><br><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">myname &#x3D; &#39;极客时间&#39;</span><br></pre></td></tr></table></figure>

<p>如下图示：</p>
<p><img src="../../../../images/02/wy-03.png" alt="Image text"></p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如我们所模拟的那样。但，这并不准确。实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被JavaScript引擎放入内存中。对，你没听错，一段JavaScript代码在执行之前需要被JavaScript引擎编译，编译完成之后，才会进入执行阶段。大致流程你可以参考下图：</p>
<p><img src="../../../../images/02/wy-08.png" alt="Image text"></p>
<h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1.编译阶段"></a>1.编译阶段</h3><p>那么编译阶段和变量提升存在什么关系呢？</p>
<p>为了搞清楚这个问题，我们还是回过头来看上面那段模拟变量提升的代码，为了方便介绍，可以把这段代码分成两部分。</p>
<p><strong>第一部分：变量提升部分的代码。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="literal">undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;函数showName被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二部分：执行部分的代码。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line">myname = <span class="string">&#x27;极客时间&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面我们就可以把JavaScript的执行流程细化，如下图所示：</p>
<p><img src="../../../../images/02/wy-09.png" alt="Image text"></p>
<p>可以发现，编译阶段，我们的JS代码会被分成执行上下文和可执行代码</p>
<h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2.执行阶段"></a>2.执行阶段</h3><p>JavaScript引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程</p>
<ul>
<li>当执行到showName函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数，并输出“函数showName被执行”结果。</li>
<li>接下来打印“myname”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在myname变量，并且其值为undefined，所以这时候就输出undefined。</li>
<li>接下来执行第3行，把“极客时间”赋给myname变量，赋值后变量环境中的myname属性值改变为“极客时间”</li>
<li>对于变量名相同的问题，后面的会直接覆盖前面的赋值操作。</li>
</ul>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>编译阶段会涉及到函数调用栈</p>
<p><strong>JavaScript引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2</span><br><span class="line">function add(b,c)&#123;</span><br><span class="line">  return b+c</span><br><span class="line">&#125;</span><br><span class="line">function addAll(b,c)&#123;</span><br><span class="line">var d &#x3D; 10</span><br><span class="line">result &#x3D; add(b,c)</span><br><span class="line">return  a+result+d</span><br><span class="line">&#125;</span><br><span class="line">addAll(3,6)</span><br></pre></td></tr></table></figure>

<p>上面这段代码，我们分析一下调用栈的过程</p>
<ul>
<li><p><strong>创建全局上下文，并将其压入栈底</strong>。如下图所示</p>
<p><img src="../../../../images/02/wy-04.png" alt="Image text"></p>
<p>变量a、函数add和addAll都保存到了全局上下文的变量环境对象中。</p>
<p>紧接着，执行变量赋值和函数执行操作，如下图示</p>
<p><img src="../../../../images/02/wy-05.png" alt="Image text"></p>
</li>
<li><p><strong>当执行函数addAll时，JS引擎会编译该函数，并为其创建一个执行上下文，压入栈中</strong></p>
<p><img src="../../../../images/02/wy-06.png" alt="Image text"></p>
<p>同样是，在函数内部，也是先申明，变量提升，再执行</p>
</li>
<li><p>当执行addAll时，内部又会为add函数创建一个执行上下文，押入栈中</p>
<p><img src="../../../../images/02/wy-07.png" alt="Image text"></p>
<p>当add函数返回时，该函数的执行上下文就会从栈顶弹出，并将result的值设置为add函数的返回值，也就是9</p>
</li>
<li><p>从栈顶执行到栈底，表示整个JavaScript流程执行结束了。</p>
</li>
</ul>
<h1 id="let和const的引入"><a href="#let和const的引入" class="headerlink" title="let和const的引入"></a>let和const的引入</h1><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>JS的var变量只有函数作用域，这样会引发很多意想不到的问题，这里就不阐述了</p>
<p>ES6中通过let和const关键字，让JS也有了块级作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>这里的{}中的let变量，只会在该{}中生效，但是var变量却是foo函数中都有效</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><blockquote>
<p>通过执行上下文中的词法环境来实现let，const的块级作用域</p>
</blockquote>
<p>我们来分析下上面代码的流程</p>
<h3 id="1-编译并创建执行上下文"><a href="#1-编译并创建执行上下文" class="headerlink" title="1.编译并创建执行上下文"></a>1.编译并创建执行上下文</h3><p><img src="../../../../images/02/wy-11.png" alt="Image text"></p>
<p>通过上图，我们可以得出以下结论：</p>
<ul>
<li>函数内部通过var声明的变量，在编译阶段全都被存放到变量环境里面了。</li>
<li>通过let声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</li>
<li>在函数的作用域内部，通过let声明的变量并没有被存放到词法环境中。</li>
<li>接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中a的值已经被设置成了1，词法环境中b的值已经被设置成了2。</li>
</ul>
<h3 id="2-代码块变量的执行"><a href="#2-代码块变量的执行" class="headerlink" title="2.代码块变量的执行"></a>2.代码块变量的执行</h3><p>这时候函数的执行上下文就如下图所示：</p>
<p><img src="../../../../images/02/wy-12.png" alt="Image text"></p>
<ul>
<li>声明的变量执行完后，进入执行阶段</li>
<li>此时外层的let b赋值，代码块执行，变量还是先声明在赋值</li>
</ul>
<p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let或者const声明的变量。</p>
<p><img src="../../../../images/02/wy-13.png" alt="Image text"></p>
<p><strong>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出</strong>，最终执行上下文如下图所示：</p>
<p><img src="../../../../images/02/wy-14.png" alt="Image text"></p>
<p><strong>这样我们代码块中的变量就实现了只在代码块中起作用。</strong></p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>通过词法环境的小型栈来实现了代码块中let和const变量的块级作用域效果</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>理解作用域链是理解闭包的基础</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p><strong>每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。</strong></p>
<p>当一段JS代码使用了一个变量时，引擎会在“当前执行上下文”中寻找该变量，如果没有找到，会寻找其外部引用里的“执行上下文”中变量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">    console.log(myName)</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var myName &#x3D; &quot; 极客邦 &quot;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line">var myName &#x3D; &quot; 极客时间 &quot;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>比如上面代码，bar中的myName没有找到，会寻找全局中的myName，分析入下图示：</p>
<p><img src="../../../../images/02/wy-15.png" alt="Image text"></p>
<p><img src="../../../../images/02/wy-16.png" alt="Image text"></p>
<p>此时，你可能又会疑惑，为啥bar函数不是引用foo函数里面的myName变量，这就有涉及到外部引用out的引用规则</p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><blockquote>
<p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符</p>
</blockquote>
<p>看下面这张图：</p>
<p><img src="../../../../images/02/wy-17.png" alt="Image text"></p>
<p>从图中可以看出，<strong>词法作用域就是根据代码的位置来决定的</strong>，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—&gt;bar 函数作用域—&gt;main 函数作用域—&gt; 全局作用域。</p>
<h2 id="块级作用域中变量查找"><a href="#块级作用域中变量查找" class="headerlink" title="块级作用域中变量查找"></a>块级作用域中变量查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">    var myName &#x3D; &quot; 极客世界 &quot;</span><br><span class="line">    let test1 &#x3D; 100</span><br><span class="line">    if (1) &#123;</span><br><span class="line">        let myName &#x3D; &quot;Chrome 浏览器 &quot;</span><br><span class="line">        console.log(test)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var myName &#x3D; &quot; 极客邦 &quot;</span><br><span class="line">    let test &#x3D; 2</span><br><span class="line">    &#123;</span><br><span class="line">        let test &#x3D; 3</span><br><span class="line">        bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myName &#x3D; &quot; 极客时间 &quot;</span><br><span class="line">let myAge &#x3D; 10</span><br><span class="line">let test &#x3D; 1</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>直接上图：</p>
<p><img src="../../../../images/02/wy-18.png" alt="Image text"></p>
<p>也是正常的理解：顺序为 ：自己的块级作用域-&gt;自己的上下文变量环境-&gt;out的块级作用域-&gt;out上下文变量环境</p>
<h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><p>闭包的最直观解释就是函数内嵌套了函数，并且内部函数引用了外部函数的变量</p>
<p>我们来看下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    var myName &#x3D; &quot; 极客时间 &quot;</span><br><span class="line">    let test1 &#x3D; 1</span><br><span class="line">    const test2 &#x3D; 2</span><br><span class="line">    var innerBar &#x3D; &#123;</span><br><span class="line">        getName:function()&#123;</span><br><span class="line">            console.log(test1)</span><br><span class="line">            return myName</span><br><span class="line">        &#125;,</span><br><span class="line">        setName:function(newName)&#123;</span><br><span class="line">            myName &#x3D; newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return innerBar</span><br><span class="line">&#125;</span><br><span class="line">var bar &#x3D; foo()</span><br><span class="line">bar.setName(&quot; 极客邦 &quot;)</span><br><span class="line">bar.getName()</span><br><span class="line">console.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>首先我们看看当执行到 foo 函数内部的return innerBar这行代码时调用栈的情况，你可以参考下图：</p>
<p><img src="../../../../images/02/wy-19.png" alt="Image text"></p>
<p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<p><img src="../../../../images/02/wy-20.png" alt="Image text"></p>
<p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然保存在内存中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。</p>
<p>之所以是专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的<strong>闭包</strong>。</p>
<ul>
<li><strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包</strong></li>
</ul>
<p>那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的myName = “极客邦”这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：</p>
<p><img src="../../../../images/02/wy-21.png" alt="Image text"></p>
<h1 id="this的认识"><a href="#this的认识" class="headerlink" title="this的认识"></a>this的认识</h1><p>关于 this，我们还是得先从执行上下文说起。在前面几篇文章中，我们提到执行上下文中包含了变量环境、词法环境、外部环境，但其实还有一个 this 没有提及，具体你可以参考下图：</p>
<p><img src="../../../../images/02/wy-22.png" alt="Image text"></p>
<p>从图中可以看出，this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。中我们提到过，执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。</p>
<p>实际上，this是不固定的，一般而言，<strong>对象.方法</strong>使用的时候，函数中this指向的就是该对象，如果是直接调用，一般默认都是window对象</p>
<p>比如，如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myObj &#x3D; &#123;</span><br><span class="line">  name : &quot; 极客时间 &quot;, </span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    function bar()&#123;console.log(this)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>可以看到，showThis由myObj调用，所以this就是myObj，但是showThis内部的函数bar被调用的时候，前面没有对象引用，默认是window，所以bar函数中的this指向的就是window</p>
<h2 id="避免this问题"><a href="#避免this问题" class="headerlink" title="避免this问题"></a>避免this问题</h2><ul>
<li>call，bind，apply</li>
<li>定义变量改变，比如外部定义变量 let that=this</li>
<li>使用箭头函数</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> YOUNG
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="YOUNG BLOG"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>