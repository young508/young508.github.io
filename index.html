<!DOCTYPE html>


<html lang="zh">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="hexo blog" />
   
  <meta name="description" content="young blog write my world" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     young blog write my world
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/young508"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">YOUNG BLOG</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Java-JVM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/25/Java-JVM/"
    >Java JVM</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/25/Java-JVM/" class="article-date">
  <time datetime="2020-11-25T02:57:16.000Z" itemprop="datePublished">2020-11-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E8%AF%AD%E6%B3%95/">Java语法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="JVM-相关知识体系"><a href="#JVM-相关知识体系" class="headerlink" title="JVM 相关知识体系"></a>JVM 相关知识体系</h1><blockquote>
<p>本文是构建JVM核心知识点全局知识体系</p>
</blockquote>
<p><strong>文章内容主要是学习笔记，来源：<a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/jvm/java-jvm-class.html">https://www.pdai.tech/md/java/jvm/java-jvm-class.html</a></strong></p>
<h2 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h2><p><img src="../../../../images/07/10.png" alt="Image text"></p>
<h2 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h2><blockquote>
<p>不同的虚拟机实现方式上也有差别，如果没有特别指出，这里的JVM指的是sun的HotSpot；不同的JDK版本略有差别，这里主要以1.8</p>
</blockquote>
<p><img src="../../../../images/07/11.png" alt="Image text"></p>
<h1 id="JVM-基础-类字节码详解"><a href="#JVM-基础-类字节码详解" class="headerlink" title="JVM 基础 - 类字节码详解"></a>JVM 基础 - 类字节码详解</h1><h2 id="多语言编译为字节码在JVM运行"><a href="#多语言编译为字节码在JVM运行" class="headerlink" title="多语言编译为字节码在JVM运行"></a>多语言编译为字节码在JVM运行</h2><p>计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。这个编译后的java代码，就是本文要介绍的jav字节码。</p>
<p>为什么jvm不能直接运行java代码呢，这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的。所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。</p>
<ul>
<li>java代码间接翻译成字节码，储存字节码的文件再交由运行在不同平台上的jvm虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li>
<li>jvm也不再只支持java，由此衍生出了许多基于jvm的编程语言，比如groovy，scala，kotlin等等。</li>
</ul>
<p><img src="../../../../images/07/12.png" alt="Image text"></p>
<h2 id="Java字节码文件"><a href="#Java字节码文件" class="headerlink" title="Java字节码文件"></a>Java字节码文件</h2><p>class文件本质上一个以8位字节为基础单位的二进制流，各个数据项目按照严格顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</p>
<p>class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。这里暂不详细的讲。</p>
<p>本文将通过简单的java例子编译后的文件来理解。</p>
<h3 id="class文件的结构属性"><a href="#class文件的结构属性" class="headerlink" title="class文件的结构属性"></a>class文件的结构属性</h3><p>在理解之前先从整体看下java字节码文件包含了哪些类型的数据。</p>
<p><img src="../../../../images/07/13.png" alt="Image text"></p>
<h3 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h3><p>下面以一个简单的例子来逐步讲解字节码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Main.java</span><br><span class="line">public class Main &#123;</span><br><span class="line">    </span><br><span class="line">    private int m;</span><br><span class="line">    </span><br><span class="line">    public int inc() &#123;</span><br><span class="line">        return m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以下命令，可以在当前所在路径下生成一个Main.class文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br></pre></td></tr></table></figure>

<p>以文本的形式打开生成的class文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0034 0013 0a00 0400 0f09</span><br><span class="line">0003 0010 0700 1107 0012 0100 016d 0100</span><br><span class="line">0149 0100 063c 696e 6974 3e01 0003 2829</span><br><span class="line">5601 0004 436f 6465 0100 0f4c 696e 654e</span><br><span class="line">756d 6265 7254 6162 6c65 0100 0369 6e63</span><br><span class="line">0100 0328 2949 0100 0a53 6f75 7263 6546</span><br><span class="line">696c 6501 0009 4d61 696e 2e6a 6176 610c</span><br><span class="line">0007 0008 0c00 0500 0601 0010 636f 6d2f</span><br><span class="line">7268 7974 686d 372f 4d61 696e 0100 106a</span><br><span class="line">6176 612f 6c61 6e67 2f4f 626a 6563 7400</span><br><span class="line">2100 0300 0400 0000 0100 0200 0500 0600</span><br><span class="line">0000 0200 0100 0700 0800 0100 0900 0000</span><br><span class="line">1d00 0100 0100 0000 052a b700 01b1 0000</span><br><span class="line">0001 000a 0000 0006 0001 0000 0003 0001</span><br><span class="line">000b 000c 0001 0009 0000 001f 0002 0001</span><br><span class="line">0000 0007 2ab4 0002 0460 ac00 0000 0100</span><br><span class="line">0a00 0000 0600 0100 0000 0800 0100 0d00</span><br><span class="line">0000 0200 0e</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件开头的4个字节(“cafe babe”)称之为 <code>魔数</code>，唯有以”cafe babe”开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。</p>
</li>
<li><p>0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。</p>
</li>
<li><p>继续往下是常量池… 知道是这么分析的就可以了，然后我们通过工具反编译字节码文件继续去看。</p>
</li>
</ul>
<h3 id="反编译字节码文件"><a href="#反编译字节码文件" class="headerlink" title="反编译字节码文件"></a>反编译字节码文件</h3><blockquote>
<p>使用到java内置的一个反编译工具javap可以反编译字节码文件，用法：javap <options> <classes></p>
</blockquote>
<p>其中<options>选项包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-help  --help  -?        输出此用法消息</span><br><span class="line">-version                 版本信息</span><br><span class="line">-v  -verbose             输出附加信息</span><br><span class="line">-l                       输出行号和本地变量表</span><br><span class="line">-public                  仅显示公共类和成员</span><br><span class="line">-protected               显示受保护的&#x2F;公共类和成员</span><br><span class="line">-package                 显示程序包&#x2F;受保护的&#x2F;公共类</span><br><span class="line">                         和成员 (默认)</span><br><span class="line">-p  -private             显示所有类和成员</span><br><span class="line">-c                       对代码进行反汇编</span><br><span class="line">-s                       输出内部类型签名</span><br><span class="line">-sysinfo                 显示正在处理的类的</span><br><span class="line">                         系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">-constants               显示最终常量</span><br><span class="line">-classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">-cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入命令 javap -v -p Main.class 查看输出内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;E:&#x2F;JavaCode&#x2F;TestProj&#x2F;out&#x2F;production&#x2F;TestProj&#x2F;com&#x2F;rhythm7&#x2F;Main.class</span><br><span class="line">  Last modified 2018-4-7; size 362 bytes</span><br><span class="line">  MD5 checksum 4aed8540b098992663b7ba08c65312de</span><br><span class="line">  Compiled from &quot;Main.java&quot;</span><br><span class="line">public class com.rhythm7.Main</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #4.#18         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #3.#19         &#x2F;&#x2F; com&#x2F;rhythm7&#x2F;Main.m:I</span><br><span class="line">   #3 &#x3D; Class              #20            &#x2F;&#x2F; com&#x2F;rhythm7&#x2F;Main</span><br><span class="line">   #4 &#x3D; Class              #21            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #5 &#x3D; Utf8               m</span><br><span class="line">   #6 &#x3D; Utf8               I</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #12 &#x3D; Utf8               this</span><br><span class="line">  #13 &#x3D; Utf8               Lcom&#x2F;rhythm7&#x2F;Main;</span><br><span class="line">  #14 &#x3D; Utf8               inc</span><br><span class="line">  #15 &#x3D; Utf8               ()I</span><br><span class="line">  #16 &#x3D; Utf8               SourceFile</span><br><span class="line">  #17 &#x3D; Utf8               Main.java</span><br><span class="line">  #18 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #19 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; m:I</span><br><span class="line">  #20 &#x3D; Utf8               com&#x2F;rhythm7&#x2F;Main</span><br><span class="line">  #21 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">&#123;</span><br><span class="line">  private int m;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  public com.rhythm7.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom&#x2F;rhythm7&#x2F;Main;</span><br><span class="line"></span><br><span class="line">  public int inc();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  &#x2F;&#x2F; Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  this   Lcom&#x2F;rhythm7&#x2F;Main;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Main.java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字节码文件信息"><a href="#字节码文件信息" class="headerlink" title="字节码文件信息"></a>字节码文件信息</h3><p>开头的7行信息包括：Class文件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪些文件，类的权限定名，jdk次版本号，主版本号。</p>
<p>然后紧接这的是该累的访问标志：ACC_PUBLIC,ACC_SUPER，访问标志的含义如下：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为Public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令的新语义．</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志这个类并非由用户代码产生</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>Constant pool :常量池</p>
<p>常量池可以理解为Class文件中的资源仓库。主要存放的是两大类常量：字面量（Lietral）和符号引用（Symbolic References）。字面量类似于java中的常量概念，如文本字符串，final常量等，而符号引用则属于编译原理方面的概念，包括以下三种：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符号</li>
<li>方法的名称和描述符</li>
</ul>
<p>不同于C/C++，jvm是在加载class文件的时候才进行的动态链接，也就是说这些子弹和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或者运行时解析并翻译到具体的内存地址中。直接通过反编译文件来查看字节码内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#1 &#x3D; Methodref          #4.#18         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#4 &#x3D; Class              #21            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">#7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">#8 &#x3D; Utf8               ()V</span><br><span class="line">#18 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#21 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个常量是一个方法定义，指向了第4和第18个常量。以此类推查看第4和第18个常量。最后可以拼接成第一个常量右侧的注释内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure>

<p>这段可以理解为该类的实例构造器的声明，由于main类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了main类的直接父类是Object。该方法默认返回值是V，也就是void，无返回值。</p>
<p>第二个常量同理可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#2 &#x3D; Fieldref           #3.#19         &#x2F;&#x2F; com&#x2F;rhythm7&#x2F;Main.m:I</span><br><span class="line">#3 &#x3D; Class              #20            &#x2F;&#x2F; com&#x2F;rhythm7&#x2F;Main</span><br><span class="line">#5 &#x3D; Utf8               m</span><br><span class="line">#6 &#x3D; Utf8               I</span><br><span class="line">#19 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; m:I</span><br><span class="line">#20 &#x3D; Utf8               com&#x2F;rhythm7&#x2F;Main</span><br></pre></td></tr></table></figure>

<p>复制代码此处声明了一个字段m，类型为I，I即是int类型。关于字节码的类型对应如下：</p>
<table>
<thead>
<tr>
<th>标识字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本类型int</td>
</tr>
<tr>
<td>S</td>
<td>基本类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>特殊类型void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，以分号结尾，如Ljava/lang/Object;</td>
</tr>
</tbody></table>
<p>对于数组类型，每一位使用一个前置的[字符来描述，如定义一个java.lang.String[]/[]类型的二维数组，将被记录为[[Ljava/lang/String;</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的16进制文件内容如何，我们直接看反编译后的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private int m;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PRIVATE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此处声明了一个私有变量m，类型为int，返回值为int。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public com.rhythm7.Main();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        4: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 3: 0</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0       5     0  this   Lcom&#x2F;rhythm7&#x2F;Main;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是构造方法：Main()，返回值为void，公开方法。</p>
<p>code内的主要属性为：</p>
<ul>
<li><strong>stack</strong>: 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1</li>
<li><strong>locals</strong>: 局部变量所需的存储空间，单位为Slot, Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。</li>
<li><strong>args_size</strong>: 方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this</li>
<li><strong>attribute_info</strong>: 方法体内容，0,1,4为字节码”行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的”java/lang/Object.””😦)V”, 然后执行返回语句，结束方法。</li>
<li><strong>LineNumberTable</strong>: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</li>
<li><strong>LocalVariableTable</strong>: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。 start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。</li>
</ul>
<p>同理可以分析Main类中的另一个方法”inc()”:</p>
<p>方法体内的内容是：将this入栈，获取字段#2并置于栈顶, 将int类型的1入栈，将栈内顶部的两个数值相加，返回一个int类型的值。</p>
<h3 id="kotlin-函数扩展的实现"><a href="#kotlin-函数扩展的实现" class="headerlink" title="kotlin 函数扩展的实现"></a>kotlin 函数扩展的实现</h3><p>kotlin提供了扩展函数的语言特性，借助这个特性，我们可以给任意对象添加自定义方法。</p>
<p>以下示例为Object添加”sayHello”方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;SayHello.kt</span><br><span class="line">package com.rhythm7</span><br><span class="line"></span><br><span class="line">fun Any.sayHello() &#123;</span><br><span class="line">    println(&quot;Hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译后，使用javap查看生成SayHelloKt.class文件的字节码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Classfile &#x2F;E:&#x2F;JavaCode&#x2F;TestProj&#x2F;out&#x2F;production&#x2F;TestProj&#x2F;com&#x2F;rhythm7&#x2F;SayHelloKt.class</span><br><span class="line">Last modified 2018-4-8; size 958 bytes</span><br><span class="line"> MD5 checksum 780a04b75a91be7605cac4655b499f19</span><br><span class="line"> Compiled from &quot;SayHello.kt&quot;</span><br><span class="line">public final class com.rhythm7.SayHelloKt</span><br><span class="line"> minor version: 0</span><br><span class="line"> major version: 52</span><br><span class="line"> flags: ACC_PUBLIC, ACC_FINAL, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">    &#x2F;&#x2F;省略常量池部分字节码</span><br><span class="line">&#123;</span><br><span class="line"> public static final void sayHello(java.lang.Object);</span><br><span class="line">   descriptor: (Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">   Code:</span><br><span class="line">     stack&#x3D;2, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: ldc           #9                  &#x2F;&#x2F; String $receiver</span><br><span class="line">        3: invokestatic  #15                 &#x2F;&#x2F; Method kotlin&#x2F;jvm&#x2F;internal&#x2F;Intrinsics.checkParameterIsNotNull:(Ljava&#x2F;lang&#x2F;Object;Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">        6: ldc           #17                 &#x2F;&#x2F; String Hello</span><br><span class="line">        8: astore_1</span><br><span class="line">        9: getstatic     #23                 &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       12: aload_1</span><br><span class="line">       13: invokevirtual #28                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">       16: return</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0      17     0 $receiver   Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 4: 6</span><br><span class="line">       line 5: 16</span><br><span class="line">   RuntimeInvisibleParameterAnnotations:</span><br><span class="line">     0:</span><br><span class="line">       0: #7()</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;SayHello.kt&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>观察头部发现,koltin为文件SayHello生成了一个类，类名”com.rhythm7.SayHelloKt”.</p>
<p>由于我们一开始编写SayHello.kt时并不希望SayHello是一个可实例化的对象类，所以，SayHelloKt是无法被实例化的，SayHelloKt并没有任何一个构造器。</p>
<p>再观察唯一的一个方法：发现Any.sayHello()的具体实现是静态不可变方法的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final void sayHello(java.lang.Object);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以当我们在其他地方使用Any.sayHello()时，事实上等同于调用java的SayHelloKt.sayHello(Object)方法。</p>
<p>顺便一提的是，当扩展的方法为Any时，意味着Any是non-null的，这时，编译器会在方法体的开头检查参数的非空，即调用 <code>kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull(Object value, String paramName)</code> 方法来检查传入的Any类型对象是否为空。如果我们扩展的函数为<code>Any?.sayHello()</code>，那么在编译后的文件中则不会有这段字节码的出现。</p>
<h1 id="JVM-基础-Java-类加载机制"><a href="#JVM-基础-Java-类加载机制" class="headerlink" title="JVM 基础 - Java 类加载机制"></a>JVM 基础 - Java 类加载机制</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>其中类的加载过程包括了加载，校验，准备，解析，初始化五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，*而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)*。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<p><img src="../../../../images/07/14.png" alt="Image text"></p>
<h3 id="类的加载-查找并加载类的二进制数据"><a href="#类的加载-查找并加载类的二进制数据" class="headerlink" title="类的加载: 查找并加载类的二进制数据"></a>类的加载: 查找并加载类的二进制数据</h3><p>加载时类加载的第一阶段，在加载阶段，虚拟机需要完成三件事情：</p>
<ul>
<li>通过类的全限定名来获取其定义的二进制流。</li>
<li>将这个字节流所代表的静态储存结构转化为方法区的运行时数据结构。</li>
<li>在java堆中，生成一个java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p><img src="../../../../images/07/15.png" alt="Image text"></p>
<p>相对于类加载的其他阶段而言，<em>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<blockquote>
<p>加载.Class文件方式</p>
</blockquote>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证-确保被加载的类的正确性"><a href="#验证-确保被加载的类的正确性" class="headerlink" title="验证: 确保被加载的类的正确性"></a>验证: 确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作:</p>
<ul>
<li><p><code>文件格式验证</code>: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
</li>
<li><p><code>元数据验证</code>: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</p>
</li>
<li><p><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
</li>
<li><p><code>符号引用验证</code>: 确保解析动作能正确执行。</p>
</li>
</ul>
<blockquote>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，<em>如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></p>
</blockquote>
<h4 id="准备-为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备-为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备: 为类的静态变量分配内存，并将其初始化为默认值"></a>准备: 为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并赋初始值的阶段。<strong>这些内存都将在方法区中分配</strong>。对于该阶段有几点需要注意：</p>
<ul>
<li><p>这时候进行内存分配的只有静态的类变量，而不包括实例变量，实例变量会在对象初始化的过程中分配在堆中。</p>
</li>
<li><p>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</p>
</li>
</ul>
<p>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点</p>
</blockquote>
<ul>
<li>对于基本数据类型来说，对于类变量（static）和全局变量，如果不显式的对其赋值而直接操作，则系统会为其默认的赋予0值，而对于局部变量来说，在使用前必须显式的为其赋值，否则编译不通过。</li>
<li>对于static final 同时修饰的变量，必须显式的赋值，否则编译无法通过；而只被final修饰的常量则可以在声明的时候赋值也可以在使用的时候赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
<li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li>
</ul>
<h4 id="解析-把类中的符号引用转换为直接引用"><a href="#解析-把类中的符号引用转换为直接引用" class="headerlink" title="解析: 把类中的符号引用转换为直接引用"></a>解析: 把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p>
<ul>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<p><strong>JVM初始化步骤</strong></p>
<ul>
<li>假设这个类还没有加载和连接，则会先对该类进行加载和连接</li>
<li>如果该类父类还没有初始化，则会先对父类进行初始化（又会进行上一步的判断）</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>
<ul>
<li><p>创建类的实例，也就是new的方式</p>
</li>
<li><p>访问某个类或接口的静态变量（final变量除外），或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射(如Class.forName(“com.pdai.jvm.Test”))</p>
</li>
<li><p>初始化某个类的子类，则其父类也会被初始化</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</p>
</li>
</ul>
<p><strong>类的不会进行初始化包括：</strong></p>
<ul>
<li>调用静态常量，也就是static final修饰的。</li>
<li>子类调用父类的静态变量。</li>
<li>通过数组定义类引用，不会触发类的初始化。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><strong>Java虚拟机将结束生命周期的几种情况</strong></p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h2 id="类加载器，-JVM类加载机制"><a href="#类加载器，-JVM类加载机制" class="headerlink" title="类加载器， JVM类加载机制"></a>类加载器， JVM类加载机制</h2><h3 id="类加载器的层次"><a href="#类加载器的层次" class="headerlink" title="类加载器的层次"></a>类加载器的层次</h3><p><img src="../../../../images/07/16.png" alt="Image text"></p>
<blockquote>
<p>注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
</blockquote>
<blockquote>
<p>站在java虚拟机的角度，只存在两种不同的类加载器：启动类加载器，它使用C++实现（这里仅限于<code>Hotspot</code>，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的）是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都是java语言来实现的，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
</blockquote>
<p><strong>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类</strong> :</p>
<p><code>启动类加载器</code>: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</p>
<p><code>扩展类加载器</code>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<p><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:</p>
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
<h3 id="寻找类加载器"><a href="#寻找类加载器" class="headerlink" title="寻找类加载器"></a>寻找类加载器</h3><p>寻找类加载器小例子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.pdai.jvm.classloader;</span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader loader &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@64fef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</span><br><span class="line">null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父Loader，原因是<code>BootstrapLoader</code>(引导类加载器)是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回<code>null</code>。</p>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类加载有三种方式:</p>
<p>1、命令行启动应用时候由JVM初始化加载</p>
<p>2、通过Class.forName()方法动态加载</p>
<p>3、通过ClassLoader.loadClass()方法动态加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.pdai.jvm.classloader;</span><br><span class="line">public class loaderTest &#123; </span><br><span class="line">        public static void main(String[] args) throws ClassNotFoundException &#123; </span><br><span class="line">                ClassLoader loader &#x3D; HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                &#x2F;&#x2F;使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span><br><span class="line">                loader.loadClass(&quot;Test2&quot;); </span><br><span class="line">                &#x2F;&#x2F;使用Class.forName()来加载类，默认会执行初始化块 </span><br><span class="line">&#x2F;&#x2F;                Class.forName(&quot;Test2&quot;); </span><br><span class="line">                &#x2F;&#x2F;使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span><br><span class="line">&#x2F;&#x2F;                Class.forName(&quot;Test2&quot;, false, loader); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test2 &#123; </span><br><span class="line">        static &#123; </span><br><span class="line">                System.out.println(&quot;静态初始化块执行了！&quot;); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分别切换加载方式，会有不同的输出结果。</p>
<blockquote>
<p>Class.forName()和ClassLoader.loadClass()区别?</p>
</blockquote>
<ul>
<li><p>Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p>
</li>
<li><p>ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p>
</li>
<li><p>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</p>
</li>
</ul>
<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><ul>
<li><p><code>全盘负责</code>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
</li>
<li><p><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
</li>
<li><p><code>缓存机制</code>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
</li>
<li><p><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 </p>
<p><strong>双亲委派机制</strong> </p>
<ul>
<li>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 </li>
<li>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 </li>
<li>3、如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载； </li>
<li>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<p><strong>双亲委派代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;</span><br><span class="line">            return loadClass(name, false);</span><br><span class="line">    &#125;</span><br><span class="line">    protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;</span><br><span class="line">            &#x2F;&#x2F; 首先判断该类型是否已经被加载</span><br><span class="line">            Class c &#x3D; findLoadedClass(name);</span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                         &#x2F;&#x2F;如果存在父类加载器，就委派给父类加载器加载</span><br><span class="line">                        c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span><br><span class="line">                        c &#x3D; findBootstrapClass0(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                 &#x2F;&#x2F; 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span><br><span class="line">                    c &#x3D; findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>双亲委派优势</strong></p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.pdai.jvm.classloader;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String root;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        byte[] classData &#x3D; loadClassData(name);</span><br><span class="line">        if (classData &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new ClassNotFoundException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return defineClass(name, classData, 0, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] loadClassData(String className) &#123;</span><br><span class="line">        String fileName &#x3D; root + File.separatorChar</span><br><span class="line">                + className.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream ins &#x3D; new FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">            int bufferSize &#x3D; 1024;</span><br><span class="line">            byte[] buffer &#x3D; new byte[bufferSize];</span><br><span class="line">            int length &#x3D; 0;</span><br><span class="line">            while ((length &#x3D; ins.read(buffer)) !&#x3D; -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoot(String root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        MyClassLoader classLoader &#x3D; new MyClassLoader();</span><br><span class="line">        classLoader.setRoot(&quot;D:\\temp&quot;);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; testClass &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            testClass &#x3D; classLoader.loadClass(&quot;com.pdai.jvm.classloader.Test2&quot;);</span><br><span class="line">            Object object &#x3D; testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。</p>
<p><strong>这里有几点需要注意</strong> :</p>
<p>1、这里传递的文件名需要是类的全限定性名称，即<code>com.pdai.jvm.classloader.Test2</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</p>
<p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p>
<p>3、这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>
<h1 id="JVM-基础-JVM-内存结构"><a href="#JVM-基础-JVM-内存结构" class="headerlink" title="JVM 基础 - JVM 内存结构"></a>JVM 基础 - JVM 内存结构</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="../../../../images/07/17.png" alt="Image text"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址(如果正在执行的是本地方法则为空)。</p>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息，从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><img src="../../../../images/07/18.png" alt="Image text"></p>
<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss512M HackTheJava</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常:</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法一般是用其它语言(C、C++ 或汇编语言等)编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p><img src="../../../../images/07/19.png" alt="Image text"></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有对象都在这里分配内存，是垃圾收集的主要区域(“GC 堆”)。</p>
<p>所有对象都在这里分配内存，是垃圾收集的主要区域(“GC 堆”)。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，针对不同类型的对象采取不同的垃圾回收算法，可以将堆分成两块:</p>
<ul>
<li>新生代(Young Generation)</li>
<li>老年代(Old Generation)</li>
<li>也有把方法区称为永生代（Permenent Generation）</li>
</ul>
<p>新生代可以继续划分成以下三个空间:</p>
<ul>
<li>Eden(伊甸园)</li>
<li>From Survivor(幸存者)</li>
<li>To Survivor</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收。但是从 JDK 1.7 开始，已经把原本放在永久代的字符串常量池移到 Native Method 中。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池(编译器生成的各种字面量（字面量类似于java中的常量概念，如文本字符串，final常量等）和符号引用)会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。</p>
<p>这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<h1 id="JVM-基础-Java-垃圾收集"><a href="#JVM-基础-Java-垃圾收集" class="headerlink" title="JVM 基础 - Java 垃圾收集"></a>JVM 基础 - Java 垃圾收集</h1><blockquote>
<ul>
<li><p>垃圾收集主要是针对堆和方法区进行</p>
</li>
<li><p>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。</p>
</li>
</ul>
</blockquote>
<h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计算器+1，当对象减少一个引用时，计算器-1，当对象的引用计算值为0时，表示可被回收。两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>
<p>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line"></span><br><span class="line">    public Object instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReferenceCountingGC objectA &#x3D; new ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objectB &#x3D; new ReferenceCountingGC();</span><br><span class="line">        objectA.instance &#x3D; objectB;</span><br><span class="line">        objectB.instance &#x3D; objectA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p>
<p><img src="../../../../images/07/20.png" alt="Image text"></p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h3 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:</p>
<ul>
<li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<p>可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。</p>
<h3 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h3><p>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 具有四种强度不同的引用类型。</p>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf &#x3D; new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;  &#x2F;&#x2F; 使对象只被软引用关联</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来实现弱引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf &#x3D; new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p>
<p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来实现虚引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf &#x3D; new PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h3><p><img src="../../../../images/07/21.png" alt="Image text"></p>
<p>将存活的对象进行标记，然后清理掉未被标记的对象。</p>
<p>不足:</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h3><p><img src="../../../../images/07/22.png" alt="Image text"></p>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h3 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h3><p><img src="../../../../images/07/23.png" alt="Image text"></p>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用: 复制算法</li>
<li>老年代使用: 标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="../../../../images/07/24.png" alt="Image text"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li>
<li>串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><p><img src="../../../../images/07/25.png" alt="Image text"></p>
<p>Serial 翻译为串行，也就是说它以串行的方式执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
<p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
<h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h3><p><img src="../../../../images/07/26.png" alt="Image text"></p>
<p>它是 Serial 收集器的多线程版本。</p>
<p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
<p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
<h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h3><p>与 ParNew 一样是多线程收集器。</p>
<p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打卡 GC 自适应的调节策略(GC Ergonomics)，就不需要手工指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 。</p>
<h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h3><p><img src="../../../../images/07/27.png" alt="Image text"></p>
<p>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:</p>
<ul>
<li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h3><p><img src="../../../../images/07/28.png" alt="Image text"></p>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h3><p><img src="../../../../images/07/29.png" alt="Image text"></p>
<p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程:</p>
<ul>
<li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除: 不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点:</p>
<ul>
<li>吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC</li>
</ul>
<h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p><img src="../../../../images/07/30.png" alt="Image text"></p>
<p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</p>
<p><img src="../../../../images/07/31.png" alt="Image text"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="../../../../images/07/32.png" alt="Image text"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点:</p>
<ul>
<li>空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul>
<li>Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
</ul>
<h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
<h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p>
<h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p>
<h3 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:</p>
<h4 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java Object类分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/24/Java%20Object%E7%B1%BB%E5%88%86%E6%9E%90/"
    >Java Object类分析</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/24/Java%20Object%E7%B1%BB%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-11-24T09:19:47.000Z" itemprop="datePublished">2020-11-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E8%AF%AD%E6%B3%95/">Java语法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<ul>
<li><p>理论上Object类是所有类的父类，即直接或间接的继承java.lang.Object类。由于所有的类都继承在Object类，因此省略了extends Object关键字。</p>
</li>
<li><p>该类中主要有以下方法: toString(),getClass(),equals(),clone(),finalize(), 其中toString(),getClass(),equals是其中最重要的方法。</p>
</li>
<li><p>Object类中的getClass(),notify(),notifyAll(),wait()等方法被定义为final类型，因此不能重写。</p>
</li>
</ul>
</blockquote>
<h1 id="Object源码"><a href="#Object源码" class="headerlink" title="Object源码"></a>Object源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Object &#123;</span><br><span class="line"></span><br><span class="line">    private static native void registerNatives();</span><br><span class="line">    static &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">    public final native Class&lt;?&gt; getClass();</span><br><span class="line">    public native int hashCode();</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this &#x3D;&#x3D; obj);</span><br><span class="line">    &#125;</span><br><span class="line">    protected native Object clone() throws CloneNotSupportedException;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    public final native void notify();</span><br><span class="line">    public final native void notifyAll();</span><br><span class="line">    public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">    public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">        if (timeout &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                                &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &gt; 0) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void wait() throws InterruptedException &#123;</span><br><span class="line">        wait(0);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void finalize() throws Throwable &#123; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Object类中的大部分方法都是native方法，用此关键字修饰的方法是Java中的本地方法，一般是用C/C++语言来实现。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Object类中没有显示的提供构造方法，这是编译器默认提供的。</p>
<h2 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h2><p>其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。函数的执行是在静态代码块中执行的，在类首次进行加载的时候执行。</p>
<h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><p>可以看到方法用final，说明此方法不能被重写。此方法返回类运行时的类型</p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>返回对象的哈希码，是一个整数。</p>
<p>在实际使用中，要尽量保证对于不同的对象产生不同的哈希码。hashCode的典型实现是将对象的内部地址转为一个整数，但是这种实现技术不是Java语言必须要采用的。</p>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>这里就用到了 == ，比较的是这两个引用存的是否是同一地址。</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>Object clone() 方法用于创建并返回一个对象的拷贝。是native方法</p>
<p>在对该方法重写的时候，必须要继承Cloneable接口，并且调研super.clone</p>
<p>这里的clone 方法是浅拷贝，对象内<strong>属性引用</strong>的对象只会拷贝引用地址，而不会将引用的对象重新分配内存，相对应的深拷贝则会连引用的对象也重新创建。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[Subject: &quot;</span> + <span class="keyword">this</span>.hashCode() + <span class="string">&quot;,name:&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//浅拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[Student: &quot;</span> + <span class="keyword">this</span>.hashCode() + <span class="string">&quot;,subject:&quot;</span> + subject + <span class="string">&quot;,name:&quot;</span> + name + <span class="string">&quot;,age:&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当Student调研clone方法时，对象中的引用属性Subject只会是地址clone，StudentA和StudentB会持有同一份引用</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//Subject 如果也有引用类型的成员属性，也应该和 Student 类一样实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[Subject: &quot;</span> + <span class="keyword">this</span>.hashCode() + <span class="string">&quot;,name:&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            student.subject = (Subject) subject.clone();</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[Student: &quot;</span> + <span class="keyword">this</span>.hashCode() + <span class="string">&quot;,subject:&quot;</span> + subject + <span class="string">&quot;,name:&quot;</span> + name + <span class="string">&quot;,age:&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的Subject也实现了Cloneable，并且Student重写了clone函数，实现了StudentA.subject !=StudentB.subject</li>
</ul>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>可以重写，更多是日志打印</p>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h2><ul>
<li><p>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在<strong>同步方法</strong>中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</p>
</li>
<li><p>随机选择一个<strong>在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在</strong>同步方法<strong>或</strong>同步块**内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object/" rel="tag">Object</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-TCPIP协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2020/11/24/TCPIP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-11-24T03:05:01.911Z" itemprop="datePublished">2020-11-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><blockquote>
<p>现代网络系统是基于TCP/IP协议族的基础上来运作的。我们开发中常用的HTTP协议只是其内部的一个子集</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>计算机与网络设备要相互通信，那么双方之间必须基于相同的方法。或者说不通的硬件，操作系统之间的通信，必须基于一套规则，我们常把这套规则称为协议（Protocal）</p>
<p>我们一般把互联网相关联的协议集合起来统称为TCP/IP协议族</p>
<h3 id="TCP-IP分层"><a href="#TCP-IP分层" class="headerlink" title="TCP/IP分层"></a>TCP/IP分层</h3><blockquote>
<p>从上到下，一般分为：应用层，传输层，网络层，数据链路层，每层都有自己对应的协议</p>
</blockquote>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层决定了向用户提供应用服务时通信的活动</p>
<p>TCP/IP协议族内预存了各类通用的应用服务。比如FTP/DNS。我们最常用的HTTP也就是处于该层</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层对上层应用层，提供处于网络链接中的<strong>两台计算机之间</strong>的数据传输。</p>
<p>TCP（Transmission Control Protocal，传输控制协议）和UDP（User Date Protocal，用户数据包协议）处于该层</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络用来处理在网络上流动的数据包。数据包是网络传输的最小数据单元。该层规定了通过怎样的路径到达对方计算机，并把数据包传给对方。</p>
<p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层起的作用救赎在众多的选项中选择一个传输数显</p>
<p>IP协议处于该层</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>用来处理链接网络的硬件设备。一般理解的硬件设备都处于该层。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议的作用是<strong>找到对方</strong>。为了保证找到的就是要找的那个人，最重要的两个条件是IP地址和MAC地址（Media Access Control Address）</p>
<ul>
<li><p>IP地址</p>
<ul>
<li><p>指明了节点被分配到地址，是网络上分配到地址，可变。</p>
</li>
<li><p>IPV4地址一般分为abcde5类</p>
<ul>
<li>1.0.0.0-1+127</li>
<li>128-128+63</li>
<li>192-192+31</li>
<li>224-224+15</li>
<li>240-240+15</li>
</ul>
</li>
<li><p>以下列出留用的内部私有地址</p>
<ul>
<li><p>10.0.0.0–10.255.255.255</p>
</li>
<li><p>172.16.0.0–172.31.255.255</p>
</li>
<li><p>192.168.0.0–192.168.255.255</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MAC地址</p>
<ul>
<li>是网卡生产时唯一确定的地址，一般不可变</li>
</ul>
</li>
<li><p>IP间的通信依赖MAC地址。网络在通信的过程中，信息会被中转才会传到目标设备。这是，一般会ARP（Address Resolution Protocal）协议，这是一种用以解析地址到协议，根据通信方的IP地址可以反查出对应的MAC地址</p>
</li>
</ul>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP可以提供可靠的字节流服务</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><blockquote>
<p>三次握手的目的：为了让客户端和服务端都能知道自己的发送和接收服务都是正常的</p>
</blockquote>
<ul>
<li>客户端发送报文给服务端，服务端接收到了，明白到：客户端发送正常，服务端接收正常</li>
<li>服务端发送报文给客户端，客户端接受到了，明白到：客户端发送，接收正常，服务发送，接收正常</li>
<li>客户端在发送报文给客户端，告诉服务端我可以发送了，服务端接收到了，明白了：客户端发送，接收正常，服务端发送，接收正常，明白客户端要开始发送数据了</li>
<li>握手的时候，通过syn确保同一次握手过程，seq，ack确保握手的步骤</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><blockquote>
<p>四次挥手的目的：双方在数据交互完毕后可以正式断开链接</p>
</blockquote>
<ul>
<li>客户端发送final给服务端：服务端接收到，明白了客户端要停止发送了</li>
<li>服务端回复给客户端：客户端明白了，此时我可以停止发送消息了（此时客户端还可以接收消息）</li>
<li>服务端再发送final消息给客户端：客户端明白了，服务端要停止发送消息了</li>
<li>客户端回复服务端：服务端明白了，我可以停止发送功能了，然后两者断开链接</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>HTTP是无状态协议，即请求本身不会对通信状态做保存</li>
<li>通过keep-alive保存持久链接</li>
<li>管线化技术可以同时发送多个请求</li>
<li>通过cookie进行状态管理</li>
</ul>
<h3 id="请求内容"><a href="#请求内容" class="headerlink" title="请求内容"></a>请求内容</h3><h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>对称加密对一种，一般对称加密使用同一个密钥进行加密和解密</p>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>非对称加密的一种，一般是通过一对公钥和私钥进行加解密，公钥加密的数据，只要私钥可以解密，所以公钥可以公开。</p>
<h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p>client端<br>1.server端生成RSA公钥和私钥对，通过api将公钥返回给client端<br>2.client端<strong>自己生成AES密钥</strong>–aeskey<br>3.client端利用aeskey加密明文json数据，得到请求数据encryptData<br>4.client端使用RSA公钥加密AES密钥aeskey，得到encryptAesData<br>5.clinet端将encryptAesData作为请求头，encryptData作为请求体，发送到server端</p>
<p>server端<br>1.收到请求后，通过请求头得到encryptAesData，RSA私钥解密后得到aeskey<br>2.通过请求体得到encryptData，然后用aeskey解密，得到明文data类型<br>3.data转换成json格式进行后续处理</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Java 集合"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/23/Java%20%E9%9B%86%E5%90%88/"
    >Java集合</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/23/Java%20%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-11-23T14:06:35.000Z" itemprop="datePublished">2020-11-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E8%AF%AD%E6%B3%95/">Java语法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java常用的集合对象一般有list，map，set和queue，它们之间的关系如下图所示：</p>
<p><img src="../../../../images/07/01.webp" alt="Image text"></p>
<p><img src="../../../../images/07/02.webp" alt="Image text"></p>
<p>可以看到：Collection是List，Set和Queue的父类，Map和Collection并列的关系。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><blockquote>
<p>Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。</p>
</blockquote>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li><p>HashMap是居于数组和链表（链表大于8时会利用红黑树）的结构。这样设计的优势在于，兼有数组的快速查找和链表的快速插入，删除元素的优势。结构如图如下：</p>
<p><img src="../../../../images/07/04.jpg" alt="Image text"></p>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; Table数组的初始化长度,2^4&#x3D;16</span><br><span class="line">    static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30; &#x2F;&#x2F;Table数组的最大长度： 1&lt;&lt;30 2^30&#x3D;1073741824</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;负载因子：默认值为0.75。 当元素的总个数&gt;当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F;链表树化阙值： 默认值为 8 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F;红黑树链化阙值： 默认值为 6 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F;最小树化阈值，当Table所有元素超过该值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）</span><br><span class="line">    &#x2F;&#x2F;也就是说Table长度超过这个值，链表超过8才会进行转成红黑树</span><br><span class="line">    MIN_TREEIFY_CAPACITY &#x3D; 64</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><blockquote>
<p>链表实现时候元素节点Node，通过next来实现单链表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      final int hash;</span><br><span class="line">      final K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">      Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          this.hash &#x3D; hash;</span><br><span class="line">          this.key &#x3D; key;</span><br><span class="line">          this.value &#x3D; value;</span><br><span class="line">          this.next &#x3D; next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final K getKey()        &#123; return key; &#125;</span><br><span class="line">      public final V getValue()      &#123; return value; &#125;</span><br><span class="line">      public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">      public final int hashCode() &#123;</span><br><span class="line">          return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final V setValue(V newValue) &#123;</span><br><span class="line">          V oldValue &#x3D; value;</span><br><span class="line">          value &#x3D; newValue;</span><br><span class="line">          return oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final boolean equals(Object o) &#123;</span><br><span class="line">          if (o &#x3D;&#x3D; this)</span><br><span class="line">              return true;</span><br><span class="line">          if (o instanceof Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                  Objects.equals(value, e.getValue()))</span><br><span class="line">                  return true;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><ul>
<li>1.对key的hashCode()做hash运算，计算index;</li>
<li>2.如果没碰撞直接放到bucket⾥；</li>
<li>3.如果碰撞了，以链表的形式存在buckets后；</li>
<li>4.如果碰撞导致链表过⻓(⼤于等于TREEIFY_THRESHOLD)，就把链表转换成红⿊树(JDK1.8中的改动)；</li>
<li>5.如果节点已经存在就替换old value(保证key的唯⼀性)</li>
<li>6.如果bucket满了(超过load factor*current capacity)，就要resize</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里面，我们可以发现几个细节：</p>
<ul>
<li>bucket在进行扩容的时候，刚好是<strong>2的次幂</strong>，在做取模运算的效率⾼。</li>
<li>计算bucket的index时，p = tab[i = (n - 1) &amp; hash]) == null，这样效率会更高</li>
</ul>
<p><img src="../../../../images/06/05.jpg" alt="Image text"></p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><ul>
<li>1.对key的hashCode()做hash运算，计算index;</li>
<li>2.如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回；</li>
<li>3.如果有冲突，则通过key.equals(k)去查找对应的Entry;</li>
<li>4.若为树，则在树中通过key.equals(k)查找，O(logn)；</li>
<li>若为链表，则在链表中通过key.equals(k)查找，O(n).</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">      if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">          if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">              ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">              return first;</span><br><span class="line">          if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">              if (first instanceof TreeNode)</span><br><span class="line">                  return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              do &#123;</span><br><span class="line">                  if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                      ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                      return e;</span><br><span class="line">              &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>每次扩容大小是以前的2倍，为了更加方便对原来元素进行位置插入</p>
<p><img src="../../../../images/06/07.jpg" alt="Image text"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="../../../../images/06/08.jpg" alt="Image text"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。</p>
<h4 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h4><p><img src="../../../../images/07/06.webp" alt="Image text"></p>
<ul>
<li><p>特点：</p>
<ul>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点。</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
</li>
<li><p>链表的时间复杂度：O(n)，红黑树的时间复杂度：O(lgN)</p>
</li>
<li><p>定义：</p>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;K,<span class="title">V</span>&gt; <span class="title">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;K,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="regexp">//</span> red-black tree links 父节点</span><br><span class="line">    TreeNode&lt;K,V&gt; left;  <span class="regexp">//</span>左子树</span><br><span class="line">    TreeNode&lt;K,V&gt; right; <span class="regexp">//</span>右子树</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;  <span class="regexp">//</span> 删除后需要取消链接 needed to unlink <span class="keyword">next</span> upon deletion</span><br><span class="line">    boolean red;        <span class="regexp">//</span>颜色属性</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; <span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, <span class="keyword">next</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h2><blockquote>
<p>线程安全的HashMap，JDK1.8是通过synchronized，以及CAS无锁操作以保证操作的线程安全性</p>
</blockquote>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>我们来简单看下Collection源码结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">  int size();</span><br><span class="line">  </span><br><span class="line">  boolean isEmpty();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  boolean contains(Object o);</span><br><span class="line">  boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line"> </span><br><span class="line">  Iterator&lt;E&gt; iterator();</span><br><span class="line"></span><br><span class="line">  boolean add(E e);</span><br><span class="line">  boolean remove(Object o);</span><br><span class="line">  boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">  boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line">  </span><br><span class="line">  boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line">  </span><br><span class="line">  void clear();</span><br><span class="line">  boolean equals(Object o);</span><br><span class="line">  int hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上都是对常用方法对定义，子类必须要实现的方法。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><blockquote>
<p>Set的表现最像Collection，实际上，Set特点是<strong>不允许包含重复元素</strong>，也就是add的时候，如果是相同的元素会报异常，Set集成Collection，所以需要看Set的实现类，HashSet,LinkedHashSet,TreeSet</p>
</blockquote>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><blockquote>
<p>HashSet比较简单，内部是由HashMap来实现的，用HashMap的key作为Set的值，保证了不重复。Map此时的value是同一个new Object对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">			public HashSet() &#123;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>它是基于数组实现的List类</li>
<li>可以动态地调整容量</li>
<li>有序的（元素输出顺序与输入顺序一致）</li>
<li>元素可以为 null</li>
<li>不同步，非线程安全，效率高</li>
<li>查询快，增删慢</li>
<li>占用空间更小，对比 LinkedList，不用占用额外空间维护链表结构</li>
</ul>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;数组初始化容量10</span><br><span class="line">	private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;数组内有元素的个数</span><br><span class="line">	private int size;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 空对象数组</span><br><span class="line">	private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 缺省空对象数组</span><br><span class="line">	private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 底层数据结构，数组</span><br><span class="line">	transient Object[] elementData;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 最大数组容量</span><br><span class="line">	private static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认构造方法，初始为空数组。</span><br><span class="line">&#x2F;&#x2F;只有插入一条数据后才会扩展为10，而实际上默认是空的</span><br><span class="line"> public ArrayList() &#123;</span><br><span class="line">    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据指定容量创建对象数组</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建initialCapacity大小的数组</span><br><span class="line">        this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建空数组</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    &#x2F;&#x2F;转换最主要的是toArray()，这在Collection中就定义了</span><br><span class="line">    elementData &#x3D; c.toArray();</span><br><span class="line">    if ((size &#x3D; elementData.length) !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; c.toArray 有可能不返回一个 Object 数组</span><br><span class="line">        if (elementData.getClass() !&#x3D; Object[].class)</span><br><span class="line">            &#x2F;&#x2F;使用 Arrays.copy 方法拷创建一个 Object 数组</span><br><span class="line">            elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 替换为空数组</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>add</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       ensureCapacityInternal(size + 1);  &#x2F;&#x2F; size表示数组插入的值的个数，所以第一步应该确保数组的长度足够新值的插入</span><br><span class="line">       elementData[size++] &#x3D; e;  &#x2F;&#x2F;elementData保存的是添加值的数组</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">      if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123; &#x2F;&#x2F;数组扩容，每次是原来的1.5倍，通过Arrays.copyOf扩容</span><br><span class="line">      &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">      int oldCapacity &#x3D; elementData.length;</span><br><span class="line">      int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">      if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">          newCapacity &#x3D; minCapacity;</span><br><span class="line">      if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">          newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">      &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">      elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>remove</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;System.arraycopy将index后面的元素都往前移动一位，然后size-1</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">       int numMoved &#x3D; size - index - 1;</span><br><span class="line">       if (numMoved &gt; 0)</span><br><span class="line">           System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line"></span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么ArrayList是线程不安全的"><a href="#为什么ArrayList是线程不安全的" class="headerlink" title="为什么ArrayList是线程不安全的"></a>为什么ArrayList是线程不安全的</h3><p><strong>以add方法为例</strong></p>
<ol>
<li>列表大小为9，即size=9</li>
<li>线程A开始进入add方法，这时它获取到size的值为9，调用ensureCapacityInternal方法进行容量判断。</li>
<li>线程B此时也进入add方法，它获取到size的值也为9，也开始调用ensureCapacityInternal方法。</li>
<li>线程A发现需求大小为10，而elementData的大小就为10，可以容纳。于是它不再扩容，返回。</li>
<li>线程B也发现需求大小为10，也可以容纳，返回。</li>
<li>线程A开始进行设置值操作， elementData[size++] = e 操作。此时size变为10。</li>
<li>线程B也开始进行设置值操作，它尝试设置elementData[10] = e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException.</li>
</ol>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector和ArrayList类似，但是它通过锁机制，保证了线程的安全性，所以效率相对ArrayList来说会差一些。</p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><blockquote>
<p>Queue用于模拟队列这种数据结构，队列通常是指“先进先出”（FIFO）的容器。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</p>
</blockquote>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><ul>
<li>PriorityQueue保存队列元素的顺序不是按加入队列的顺序，而是按队列元素的大小进行重新排序。因此当调用peek()或pool()方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中的最小的元素。</li>
<li>当PriorityQueue中没有指定Comparator时，加入PriorityQueue的元素必须实现了Comparable接口（即元素是可比较的），否则会导致 ClassCastException。</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><blockquote>
<p>Java的LinkedList是一种常用的数据容器，与ArrayList相比，LinkedList的增删操作效率更高，而查改操作效率较低。</p>
<ul>
<li>LinkedList 实现了List 接口，能对它进行列表操作。</li>
<li>LinkedList 实现了Deque 接口，即能将LinkedList当作双端队列使用。</li>
<li>LinkedList 实现了Cloneable接口，能克隆。</li>
<li>LinkedList 实现了java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</li>
</ul>
</blockquote>
<p>是一个使用双向链表结构实现的容器</p>
<h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">		&#x2F;&#x2F;链表长度</span><br><span class="line">    transient int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;链表头元素</span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;链表尾元素</span><br><span class="line">    transient Node&lt;E&gt; last;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>node</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双向链表的节点结构</span><br><span class="line"> private static class Node&lt;E&gt; &#123;</span><br><span class="line">       E item;</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           this.item &#x3D; element;</span><br><span class="line">           this.next &#x3D; next;</span><br><span class="line">           this.prev &#x3D; prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>add</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">      linkLast(e);</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果是第一个，为头节点，否则加到最后一个节点的next节点</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">     final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">     final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">     last &#x3D; newNode;</span><br><span class="line">     if (l &#x3D;&#x3D; null)</span><br><span class="line">         first &#x3D; newNode;</span><br><span class="line">     else</span><br><span class="line">         l.next &#x3D; newNode;</span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>remove</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过first来一步一步查找下一个节点，找到后再unlink操作链表删除</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">      if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">          for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">              if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                  unlink(x);</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">              if (o.equals(x.item)) &#123;</span><br><span class="line">                  unlink(x);</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&#x2F;&#x2F;删除链表某个元素x</span><br><span class="line"> E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">      &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">      final E element &#x3D; x.item;</span><br><span class="line">      final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">      final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">		&#x2F;&#x2F;如果x为第一个元素，那么删除x后，x.next就是第一个元素</span><br><span class="line">      if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">          first &#x3D; next;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      		&#x2F;&#x2F;否则x的上一个的next指向x的下一个，这样x就建立了x的上一个和下一个之间的关系</span><br><span class="line">          prev.next &#x3D; next;</span><br><span class="line">          x.prev &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line">		&#x2F;&#x2F;如果x是最后以后，那么x的pre此时就是最后一个了</span><br><span class="line">      if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">          last &#x3D; prev;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      		&#x2F;&#x2F;x的下一个的prev指向x的prev，双向链表</span><br><span class="line">          next.prev &#x3D; prev;</span><br><span class="line">          x.next &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      x.item &#x3D; null;</span><br><span class="line">      size--;</span><br><span class="line">      modCount++;</span><br><span class="line">      return element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/" rel="tag">Collection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-vue源码分析-项目结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/06/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"
    >vue源码分析--项目结构</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/06/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-11-06T12:04:40.000Z" itemprop="datePublished">2020-11-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-vue-axios分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/12/vue-axios%E5%88%86%E6%9E%90/"
    >vue-axios分析</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/12/vue-axios%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-10-12T08:10:41.000Z" itemprop="datePublished">2020-10-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a> / <a class="article-category-link" href="/categories/vue/adios/">adios</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是-axios？"><a href="#什么是-axios？" class="headerlink" title="什么是 axios？"></a>什么是 axios？</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>从浏览器中创建 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a></p>
</li>
<li><p>从 node.js 创建 <a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html">http</a> 请求</p>
</li>
<li><p>支持 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</p>
</li>
<li><p>拦截请求和响应</p>
</li>
<li><p>转换请求数据和响应数据</p>
</li>
<li><p>取消请求</p>
</li>
<li><p>自动转换 JSON 数据</p>
</li>
<li><p>客户端支持防御 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></p>
</li>
<li><p>是vue框架推荐使用的网络请求库</p>
</li>
</ul>
<p>Axios应用也是非常简单好用，可以查看文档 <a target="_blank" rel="noopener" href="http://www.axios-js.com/zh-cn/docs/%E3%80%82">http://www.axios-js.com/zh-cn/docs/。</a></p>
<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过阅读源码，来解读一下几个问题</p>
<ul>
<li>1.axios，Axios，instance之间是什么关系</li>
<li>拦截器的执行顺序，是如何串联起来的</li>
<li>为什么post请求时，请求参数是一个对象时，服务端接收不到传过来的参数</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>源码地址：<a target="_blank" rel="noopener" href="https://github.com/axios/axios%EF%BC%8C%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81%E9%83%BD%E5%9C%A8lib%E7%9B%AE%E5%BD%95%E4%B8%AD">https://github.com/axios/axios，主要代码都在lib目录中</a></p>
<h2 id="axios，Axios之间是什么关系"><a href="#axios，Axios之间是什么关系" class="headerlink" title="axios，Axios之间是什么关系"></a>axios，Axios之间是什么关系</h2><p>源码结构如下图示：</p>
<p><img src="../../../../images/06/wy-01.png" alt="Image text"></p>
<h3 id="axios-js"><a href="#axios-js" class="headerlink" title="axios.js"></a>axios.js</h3><ul>
<li><p>由于我们平时都是直接引入axios对象，打开axios.js源码发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.createInstance创建了axios对象</span><br><span class="line">var axios &#x3D; createInstance(defaults);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.</span><br><span class="line">function createInstance(defaultConfig) &#123;</span><br><span class="line">  var context &#x3D; new Axios(defaultConfig);</span><br><span class="line">  var instance &#x3D; bind(Axios.prototype.request, context);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Copy axios.prototype to instance</span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Copy context to instance</span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line"></span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原来axios对象是来自于Axios，从功能上来讲，axios是Axios的实例对象，因为我们可以发现Axios的requet方法，原型对象也复制了一份到axios实例上，但是从语法角度，axios 是Axios.prototype.request函数，<strong>即axios是请求request函数</strong></p>
</li>
<li><p>同时，下面是axios自己特有的属性，Axios没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Factory for creating new instances</span><br><span class="line">axios.create &#x3D; function create(instanceConfig) &#123;</span><br><span class="line">  return createInstance(mergeConfig(axios.defaults, instanceConfig));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Expose Cancel &amp; CancelToken</span><br><span class="line">axios.Cancel &#x3D; require(&#39;.&#x2F;cancel&#x2F;Cancel&#39;);</span><br><span class="line">axios.CancelToken &#x3D; require(&#39;.&#x2F;cancel&#x2F;CancelToken&#39;);</span><br><span class="line">axios.isCancel &#x3D; require(&#39;.&#x2F;cancel&#x2F;isCancel&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Expose all&#x2F;spread</span><br><span class="line">axios.all &#x3D; function all(promises) &#123;</span><br><span class="line">  return Promise.all(promises);</span><br><span class="line">&#125;;</span><br><span class="line">axios.spread &#x3D; require(&#39;.&#x2F;helpers&#x2F;spread&#39;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Axios-js"><a href="#Axios-js" class="headerlink" title="Axios.js"></a>Axios.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function Axios(instanceConfig) &#123;</span><br><span class="line">  this.defaults &#x3D; instanceConfig;</span><br><span class="line">  this.interceptors &#x3D; &#123;</span><br><span class="line">    request: new InterceptorManager(),</span><br><span class="line">    response: new InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Axios.prototype.request &#x3D; function request(config) &#123;</span><br><span class="line"> 	</span><br><span class="line">	......</span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Provide aliases for supported request methods</span><br><span class="line">utils.forEach([&#39;delete&#39;, &#39;get&#39;, &#39;head&#39;, &#39;options&#39;], function forEachMethodNoData(method) &#123;</span><br><span class="line">  &#x2F;*eslint func-names:0*&#x2F;</span><br><span class="line">  Axios.prototype[method] &#x3D; function(url, config) &#123;</span><br><span class="line">    return this.request(mergeConfig(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url,</span><br><span class="line">      data: (config || &#123;&#125;).data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.forEach([&#39;post&#39;, &#39;put&#39;, &#39;patch&#39;], function forEachMethodWithData(method) &#123;</span><br><span class="line">  &#x2F;*eslint func-names:0*&#x2F;</span><br><span class="line">  Axios.prototype[method] &#x3D; function(url, data, config) &#123;</span><br><span class="line">    return this.request(mergeConfig(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url,</span><br><span class="line">      data: data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数有默认配置接收和拦截器属性</li>
<li>requet请求和扩展的http请求的简单实现</li>
</ul>
<h2 id="拦截器的执行顺序，是如何串联起来的"><a href="#拦截器的执行顺序，是如何串联起来的" class="headerlink" title="拦截器的执行顺序，是如何串联起来的"></a>拦截器的执行顺序，是如何串联起来的</h2><h3 id="Axios-js-gt-request"><a href="#Axios-js-gt-request" class="headerlink" title="Axios.js-&gt;request"></a>Axios.js-&gt;request</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Dispatch a request</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Object&#125; config The config specific for this request (merged with this.defaults)</span><br><span class="line"> *&#x2F;</span><br><span class="line">Axios.prototype.request &#x3D; function request(config) &#123;</span><br><span class="line">  &#x2F;*eslint no-param-reassign:0*&#x2F;</span><br><span class="line">  &#x2F;&#x2F; Allow for axios(&#39;example&#x2F;url&#39;[, config]) a la fetch API</span><br><span class="line">  if (typeof config &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    config &#x3D; arguments[1] || &#123;&#125;;</span><br><span class="line">    config.url &#x3D; arguments[0];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    config &#x3D; config || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  config &#x3D; mergeConfig(this.defaults, config);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Set config.method</span><br><span class="line">  if (config.method) &#123;</span><br><span class="line">    config.method &#x3D; config.method.toLowerCase();</span><br><span class="line">  &#125; else if (this.defaults.method) &#123;</span><br><span class="line">    config.method &#x3D; this.defaults.method.toLowerCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    config.method &#x3D; &#39;get&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Hook up interceptors middleware</span><br><span class="line">  var chain &#x3D; [dispatchRequest, undefined];</span><br><span class="line">  var promise &#x3D; Promise.resolve(config);</span><br><span class="line"></span><br><span class="line">  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123;</span><br><span class="line">    chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123;</span><br><span class="line">    chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  while (chain.length) &#123;</span><br><span class="line">    promise &#x3D; promise.then(chain.shift(), chain.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为axios是一个函数，执行axios也就是在执行request函数</li>
<li></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-jetpack系列-dataBinding使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/11/jetpack%E7%B3%BB%E5%88%97-dataBinding%E4%BD%BF%E7%94%A8/"
    >dataBinding使用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/11/jetpack%E7%B3%BB%E5%88%97-dataBinding%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2020-10-11T03:50:46.000Z" itemprop="datePublished">2020-10-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout&gt;</span><br><span class="line">	&lt;data&gt;</span><br><span class="line">	&lt;variable&gt;</span><br><span class="line">	&lt;&#x2F;variable&gt;</span><br><span class="line">	&lt;&#x2F;data&gt;</span><br><span class="line">	</span><br><span class="line">		&quot;@&#123;user.name&#125;&quot;&#x2F;&#x2F;简单赋值</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&quot;@&#x3D;&#123;user.name&#125;&quot;&#x2F;&#x2F;双向绑定</span><br><span class="line">		</span><br><span class="line">		&quot;@&#123;()-&gt;listenr.change()&#125;&quot;</span><br><span class="line">		</span><br><span class="line">&lt;&#x2F;layout&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kotlin:</span><br><span class="line">val binding&#x3D;DatabindingUtils.bind(this,R.layout.xxx)</span><br><span class="line">binding.user&#x3D;user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">viewmodeProvider(this,ViewModelProvider.newInstanceFacotry()).get(ViewModelXXX::class.java)</span><br><span class="line">viewmodeProvider(this,ViewModelProvider.AndroidViewModelFacotry.getInstance(application).get(ViewModelXXX::class.java)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>livedata</p>
<p>viewmodel</p>
<p>hilt</p>
<p>databinding</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-vue-cli详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/08/vue-cli%E8%AF%A6%E8%A7%A3/"
    >vue-cli详解</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/08/vue-cli%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-10-08T06:43:48.000Z" itemprop="datePublished">2020-10-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a> / <a class="article-category-link" href="/categories/vue/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote>
<p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
<ul>
<li>通过 <code>@vue/cli</code> 实现的交互式的项目脚手架。</li>
<li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 实现的零配置原型开发。</li>
<li>一个运行时依赖 <ul>
<li>可升级；</li>
<li>基于 webpack 构建，并带有合理的默认配置；</li>
<li>可以通过项目内的配置文件进行配置；</li>
<li>可以通过插件进行扩展。</li>
</ul>
</li>
<li>一个丰富的官方插件集合，集成了前端生态中最好的工具。</li>
<li>一套完全图形化的创建和管理 Vue.js 项目的用户界面。</li>
</ul>
</blockquote>
<p>简言之：vue-cli可以让我们快速初始化一个vue项目，并且封装了webpack合理的配置项，让我们可以直接进行项目开发。同时，vue-cli还提供丰富的扩展功能，甚至还有一个可视化ui界面，不仅好用，还很强大，是开发vue项目的不二之选。</p>
<h1 id="项目添加配置"><a href="#项目添加配置" class="headerlink" title="项目添加配置"></a>项目添加配置</h1><blockquote>
<p>一般而言，我们创建的项目即使不配置任何文件，也是可以正常运行的，因为vue-cli做了很多合理性的配置，但是不同的项目会有不同的需求，所以几乎都会进行自定义配置。也就是vue.config.js文件。</p>
</blockquote>
<h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。</p>
<p>这个文件应该导出一个包含了选项的对象：（这里是common.js规范）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><ul>
<li>Type: <code>string</code></li>
<li>Default: <code>&#39;/&#39;</code></li>
<li>定义部署在服务器上的子目录。例如，如果你的应用被部署在 <code>https://www.my-app.com/my-app/</code>，则设置 <code>publicPath</code> 为 <code>/my-app/</code>。</li>
<li>默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 <code>https://www.my-app.com/</code></li>
</ul>
<h3 id="oututDir"><a href="#oututDir" class="headerlink" title="oututDir"></a>oututDir</h3><ul>
<li>Type: <code>string</code></li>
<li>Default: <code>&#39;dist&#39;</code></li>
<li>当运行 <code>vue-cli-service build</code> 时生成的生产环境构建文件的目录。注意目标目录在构建之前会被清除 (构建时传入 <code>--no-clean</code> 可关闭该行为)。</li>
</ul>
<h3 id="assetsDir"><a href="#assetsDir" class="headerlink" title="assetsDir"></a>assetsDir</h3><ul>
<li><p>Type: <code>string</code></p>
</li>
<li><p>Default: <code>&#39;&#39;</code></p>
</li>
<li><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 <code>outputDir</code> 的) 目录。</p>
</li>
</ul>
<h3 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h3><ul>
<li>Type: <code>string</code></li>
<li>Default: <code>&#39;index.html&#39;</code></li>
<li>指定生成的 <code>index.html</code> 的输出路径 (相对于 <code>outputDir</code>)。也可以是一个绝对路径。</li>
</ul>
<h3 id="filenameHashing"><a href="#filenameHashing" class="headerlink" title="filenameHashing"></a>filenameHashing</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>true</code></p>
<p>默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 <code>false</code> 来关闭文件名哈希。</p>
</li>
</ul>
<h3 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h3><ul>
<li>Type: <code>boolean</code></li>
<li>Default: <code>true</code></li>
<li>如果你不需要生产环境的 source map，可以将其设置为 <code>false</code> 以加速生产环境构建。sourcemap是拿来作为定位代码debug时用的</li>
</ul>
<h3 id="css-extract"><a href="#css-extract" class="headerlink" title="css.extract"></a>css.extract</h3><ul>
<li><p>Type: <code>boolean | Object</code></p>
</li>
<li><p>Default: 生产环境下是 <code>true</code>，开发环境下是 <code>false</code></p>
<p>是否将组件中的 CSS 提取至一个独立的 CSS 文件中 (而不是动态注入到 JavaScript 中的 inline 代码)。</p>
<p>是通过mini-css-extract-plugin来实现的</p>
</li>
</ul>
<h3 id="css-sourceMap"><a href="#css-sourceMap" class="headerlink" title="css.sourceMap"></a>css.sourceMap</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>false</code></p>
<p>是否为 CSS 开启 source map。设置为 <code>true</code> 之后可能会影响构建的性能。</p>
</li>
</ul>
<h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><ul>
<li><p>Type: <code>Object</code></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/dev-server/">所有 <code>webpack-dev-server</code> 的选项</a>都支持。注意：</p>
<ul>
<li>有些值像 <code>host</code>、<code>port</code> 和 <code>https</code> 可能会被命令行参数覆写。</li>
<li>有些值像 <code>publicPath</code> 和 <code>historyApiFallback</code> 不应该被修改，因为它们需要和开发服务器的 <a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/config/#publicpath">publicPath</a> 同步以保障正常的工作。</li>
</ul>
</li>
</ul>
<h3 id="configureWebpack"><a href="#configureWebpack" class="headerlink" title="configureWebpack"></a>configureWebpack</h3><ul>
<li><p>Type: <code>Object | Function</code></p>
<p>如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。</p>
<p>如果这个值是一个函数，则会接收被解析的配置作为参数。该函数既可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。</p>
</li>
</ul>
<h3 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h3><ul>
<li><p>Type: <code>Function</code></p>
<p>是一个函数，会接收一个基于 webpack-chain的 <code>ChainableConfig</code> 实例。允许对内部的 webpack 配置进行更细粒度的修改。</p>
</li>
</ul>
<h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const Timestamp &#x3D; new Date().getTime();</span><br><span class="line">const CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;);</span><br><span class="line">const productionGzipExtensions &#x3D; [&quot;js&quot;, &quot;css&quot;];</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 生产环境 sourceMap</span><br><span class="line">    productionSourceMap: false,</span><br><span class="line">    &#x2F;&#x2F; 配置线上访问的前置目录</span><br><span class="line">    publicPath: &#39;&#x2F;mp&#x2F;&#39;,</span><br><span class="line">    &#x2F;&#x2F; 打包的文件夹名</span><br><span class="line">    outputDir: &#39;mp&#39;,</span><br><span class="line">    &#x2F;&#x2F; 放置生成的静态资源js css img的文件夹</span><br><span class="line">    assetsDir: &#39;static&#39;,</span><br><span class="line">    &#x2F;&#x2F; 指定生成的html入口文件路径</span><br><span class="line">    indexPath: &#39;index.html&#39;,</span><br><span class="line">    &#x2F;&#x2F;生成的静态资源在它们的文件名中是否包含hash以便更好的控制缓存</span><br><span class="line">    filenameHashing: true,</span><br><span class="line">    css: &#123;</span><br><span class="line">        sourceMap: true &#x2F;&#x2F;打开本地开发环境下的sourceMap</span><br><span class="line">    &#125;,</span><br><span class="line">    chainWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(&#39;vue$&#39;, &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;)</span><br><span class="line">            .set(&#39;@&#39;, path.join(__dirname, &#39;src&#39;))   &#x2F;&#x2F;项目别名设置</span><br><span class="line">            .set(&#39;@pages&#39;, path.join(__dirname, &#39;src&#x2F;pages&#39;))</span><br><span class="line">            .set(&#39;@assets&#39;, path.join(__dirname, &#39;src&#x2F;assets&#39;))</span><br><span class="line">            .set(&#39;@components&#39;, path.join(__dirname, &#39;src&#x2F;components&#39;))</span><br><span class="line">            .set(&#39;@store&#39;, path.join(__dirname, &#39;src&#x2F;store&#39;))</span><br><span class="line">            .set(&#39;@utils&#39;, path.join(__dirname, &#39;src&#x2F;utils&#39;))</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;打包分析工具</span><br><span class="line">        if (process.env.use_analyzer) &#123;</span><br><span class="line">            config</span><br><span class="line">                .plugin(&#39;webpack-bundle-analyzer&#39;)</span><br><span class="line">                .use(require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">        config.externals &#x3D; &#123;</span><br><span class="line">            vue: &#39;Vue&#39;,</span><br><span class="line">            moment: &#39;moment&#39;,</span><br><span class="line">            lodash: &#39;_&#39;,</span><br><span class="line">            &#39;vue-router&#39;: &#39;VueRouter&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; js打包版本控制</span><br><span class="line">        config.output.filename &#x3D; &#96;static&#x2F;js&#x2F;[name].[hash:8].$&#123;Timestamp&#125;.js&#96;,</span><br><span class="line">        config.output.chunkFilename &#x3D; &#96;static&#x2F;js&#x2F;[name].[hash:8].$&#123;Timestamp&#125;.js&#96;,</span><br><span class="line">        &#x2F;&#x2F; Gzip压缩</span><br><span class="line">        config.plugins.push(new CompressionWebpackPlugin(&#123;</span><br><span class="line">            filename: &quot;[path].gz[query]&quot;,</span><br><span class="line">            algorithm: &#39;gzip&#39;,</span><br><span class="line">            test: new RegExp(&quot;\\.(&quot; + productionGzipExtensions.join(&quot;|&quot;) + &quot;)$&quot;), &#x2F;&#x2F;匹配文件名</span><br><span class="line">            threshold: 10240,</span><br><span class="line">            minRatio: 0.8,</span><br><span class="line">            deleteOriginalAssets: false &#x2F;&#x2F;是否删除源文件(默认)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: 8088,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &#39;&#x2F;xxx&#x2F;api&#39;: &#123;</span><br><span class="line">                target: &#39;http:&#x2F;&#x2F;api.xxx.cn&#x2F;xxx&#x2F;api&#39;,</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                ws: true,&#x2F;&#x2F;websocket</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    &#39;^&#x2F;xxx&#x2F;api&#39;: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue-cli/" rel="tag">vue-cli</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-webpack详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/07/webpack%E8%AF%A6%E8%A7%A3/"
    >webpack详解</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/07/webpack%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-10-07T14:53:21.000Z" itemprop="datePublished">2020-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a> / <a class="article-category-link" href="/categories/vue/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p><em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em></p>
</blockquote>
<p><img src="../../../../images/05/wy-01.png" alt="Image text"></p>
<p>如图所示，通过webpack可以对我们的项目源码通过我们的配置做各种各样的处理，最后会得到一系列可以放在服务器运行的文件。</p>
<p>很多时候，我们都是先接触vue再慢慢接触到webpack等概念的，首先我们需要明确的是，vue框架用到了webpack，webpack不仅仅是服务于vue框架的，它是服务于整个前端工程化开发的，包括我们的react等各种框架，都可以用webpack来做项目的模块化打包。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>webpack默认的配置文件是webpack.config.js</li>
<li>可以通过 <u>webpack –config 指定配置文件</u> 来修改默认配置文件</li>
</ul>
<h2 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.打包的入口文件，默认是下面配置</span><br><span class="line">	entry:&#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">	&#x2F;&#x2F;2.打包的输出，默认是下面配置</span><br><span class="line">	output:&#123;</span><br><span class="line">    path: &#39;.&#x2F;dist&#39;,</span><br><span class="line">    filename: &#39;main.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">	&#x2F;&#x2F;3.环境</span><br><span class="line">	mode:&#39;production&#39;,</span><br><span class="line">	&#x2F;&#x2F;4.loader模块</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;test:&#39;&#x2F;\.txt$&#x2F;&#39;,use:&#39;raw-loader&#39;&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	&#x2F;&#x2F;5.插件配置</span><br><span class="line">	plugins:[</span><br><span class="line">		new HtmlwebpackPlugin(&#123;</span><br><span class="line">			template:&#39;.&#x2F;src&#x2F;index.html&#39;</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack有四个<strong>核心概念</strong>：</p>
<ul>
<li>入口(entry)</li>
<li>输出(output)</li>
<li>loader</li>
<li>插件(plugins)</li>
</ul>
<h2 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h2><ul>
<li><p>1.安装node和npm</p>
<ul>
<li><p>直接下载node安装即可，npm内置在node包中，会同步安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">可以查看版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过npm安装webpack和webpak-cli</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;建议局部安装，所以先创建一个项目</span><br><span class="line">mkdir mywebpack</span><br><span class="line">&#x2F;&#x2F;进入到项目中</span><br><span class="line">cd mywebpack</span><br><span class="line">&#x2F;&#x2F;初始化npm</span><br><span class="line">npm init -y</span><br><span class="line">&#x2F;&#x2F;安装局部的webpack和webpack-cli（4.0以上版本需要单独安装cli）</span><br><span class="line">npm install webpack webpack-cli --save-dev</span><br><span class="line">&#x2F;&#x2F;查看是否安装成功</span><br><span class="line">.&#x2F;node_modules&#x2F;.bin&#x2F;webpack -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>官方文档也是提醒进行局部安装</p>
</li>
</ul>
</li>
</ul>
<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p><img src="../../../../images/05/wy-02.png" alt="Image text"></p>
<p>通过上面安装和项目创建，我们可以生成类似如上图所示的项目</p>
<ul>
<li><p>1.新建webpack.config.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;) &#x2F;&#x2F;path是node中的核心库，用来组成文件路径</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.打包的入口文件，默认是下面配置</span><br><span class="line">	entry:&#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">	&#x2F;&#x2F;2.打包的输出，默认是下面配置</span><br><span class="line">  output:&#123;</span><br><span class="line">    path: path.join(__dirname,&#39;dist&#39;),</span><br><span class="line">    filename: &#39;main.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">	&#x2F;&#x2F;3.环境</span><br><span class="line">	mode:&#39;production&#39;,</span><br><span class="line">	&#x2F;&#x2F;4.loader模块</span><br><span class="line">	module:&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;,</span><br><span class="line">	&#x2F;&#x2F;5.插件配置</span><br><span class="line">	plugins:[</span><br><span class="line">	</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.配置package.json脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpacktest&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;:&quot;webpack&quot;   &#x2F;&#x2F;该脚本会自动寻找.&#x2F;node_modules&#x2F;.bin&#x2F;webpack</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.44.2&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.12&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.新建src目录和入口index.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;简单输出一个文本内容</span><br><span class="line">document.write(&#39;hello webpack&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.新建页面文件index.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;..&#x2F;dist&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，引用了dist/main.js文件，此时，该文件还没有生成，需要我们通过webpack来执行生成该文件</p>
</li>
<li><p>5.打包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build  &#x2F;&#x2F;这里执行的就是npm的package.json中的脚本build</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.浏览器打开index.html，就可以看到输出的内容</p>
</li>
</ul>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="入口entry"><a href="#入口entry" class="headerlink" title="入口entry"></a>入口entry</h2><blockquote>
<ul>
<li>用来指定项目的打包入口</li>
<li>单入口：entry是一个字符串</li>
<li>多入口：entry是一个对象</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.单页面</span><br><span class="line">	entry:&#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出 output"></a>输出 output</h2><blockquote>
<ul>
<li>用来指定打包输出文件</li>
<li>output对应的是一个对象，有path和filename两个属性</li>
<li>path：打包路径</li>
<li>filename：打包出来的文件名称</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		path:path.join(__dirname,&#39;dist&#39;),&#x2F;&#x2F;通过node中的path来制定路径</span><br><span class="line">		filename:&#39;[name].js&#39; &#x2F;&#x2F;通过占位符name来兼容多页面入口</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h2><blockquote>
<ul>
<li>webpack原生只支持js和json文件类型，通过loaders可以去支持其他类型的文件并且转化为有效的模块添加到依赖图中</li>
<li>本身是一个函数，通过接收源文件作为参数，返回转换的结果</li>
<li>对一个对象</li>
</ul>
</blockquote>
<h3 id="常用的loaders"><a href="#常用的loaders" class="headerlink" title="常用的loaders"></a>常用的loaders</h3><p><img src="../../../../images/05/wy-03.png" alt="Image text"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		path:path.join(__dirname,&#39;dist&#39;),&#x2F;&#x2F;通过node中的path来制定路径</span><br><span class="line">		filename:&#39;[name].js&#39; &#x2F;&#x2F;通过占位符name来兼容多页面入口</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;test:&#39;&#x2F;\.txt$&#x2F;&#39;,use:&#39;raw-loader&#39;&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ul>
<li>test：指定匹配规则，正则</li>
<li>use：该规则下，使用哪种加载器</li>
</ul>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><blockquote>
<ul>
<li>插件是用于bundle文件的优化，资源管理和环境变量的注入</li>
<li>插件是可以作用于整个构建过程</li>
<li>是个数组对象</li>
</ul>
</blockquote>
<h3 id="常有plugins"><a href="#常有plugins" class="headerlink" title="常有plugins"></a>常有plugins</h3><p><img src="../../../../images/05/wy-04.png" alt="Image text"></p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		path:path.join(__dirname,&#39;dist&#39;),&#x2F;&#x2F;通过node中的path来制定路径</span><br><span class="line">		filename:&#39;[name].js&#39; &#x2F;&#x2F;通过占位符name来兼容多页面入口</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;test:&#39;&#x2F;\.txt$&#x2F;&#39;,use:&#39;raw-loader&#39;&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		&#x2F;&#x2F;直接将插件放到数组中</span><br><span class="line">		new HtmlWebpackPlugin(&#123;templete:&#39;.&#x2F;src&#x2F;index.html&#39;&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><blockquote>
<ul>
<li>webpack4之后才提出来的概念</li>
<li>用来指定当前的构建环境是production，development还是none</li>
<li>设置mode可以默认使用webpack内置的函数，默认值是production</li>
</ul>
</blockquote>
<p><img src="../../../../images/05/wy-05.png" alt="Image text"></p>
<h1 id="loader应用"><a href="#loader应用" class="headerlink" title="loader应用"></a>loader应用</h1><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><ul>
<li><p>作用：将es6语法转为es5语法</p>
</li>
<li><p>本地安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;i是install缩写。 -D是--save-dev缩写</span><br><span class="line">npm i @babel&#x2F;core @babel&#x2F;preset-env babel-loader -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目中新建.babelrc文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;:[</span><br><span class="line">    &quot;@babel&#x2F;preset-env&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack.config.js文件添加loader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;.js$&#x2F;,</span><br><span class="line">      use: &#39;babel-loader&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解析css"><a href="#解析css" class="headerlink" title="解析css"></a>解析css</h2><blockquote>
<ul>
<li>css-loader：用于加载.css文件，并且转化为commonjs对象</li>
<li>style-loader：将样式通过style标签插入到head中</li>
</ul>
</blockquote>
<ul>
<li>本地安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-loader style-loader -D</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件配置</p>
<p>这里注意，对于同个文件需要多个loader来处理时，需要使用数组，并且此时loader是从右到左来执行</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;.js$&#x2F;,</span><br><span class="line">      use: &#39;babel-loader&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;.css$&#x2F;,</span><br><span class="line">      use: [&#39;style-loader&#39;,</span><br><span class="line">        &#39;css-loader&#39;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><blockquote>
<ul>
<li>less</li>
<li>Less-loader</li>
</ul>
</blockquote>
<ul>
<li>本地安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less less-loader -D</span><br></pre></td></tr></table></figure>

<ul>
<li>文件配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     test: &#x2F;.less$&#x2F;,</span><br><span class="line">     use: [&#39;style-loader&#39;,</span><br><span class="line">       &#39;css-loader&#39;,</span><br><span class="line">       &#39;less-loader&#39;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片-字体"><a href="#图片-字体" class="headerlink" title="图片/字体"></a>图片/字体</h2><blockquote>
<p>file-loader</p>
</blockquote>
<ul>
<li>本地安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i file-loader -D</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     test: &#x2F;(jpg|jpeg|png|gif|svg)$&#x2F;,</span><br><span class="line">     use:&#39;file-loader&#39;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h1 id="plugins应用"><a href="#plugins应用" class="headerlink" title="plugins应用"></a>plugins应用</h1><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>配置，该插件是webpack自带的，所以引入即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">  &#x2F;&#x2F;3.环境</span><br><span class="line"> mode: &#39;dev&#39;,</span><br><span class="line"> &#x2F;&#x2F;5.插件配置</span><br><span class="line"> plugins: [</span><br><span class="line">   new webpack.HotModuleReplacementPlugin()</span><br><span class="line"> ],</span><br><span class="line"> devServe:&#123;</span><br><span class="line">   contentBase:&#39;.&#x2F;dist&#39;,</span><br><span class="line">   hot:true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>package.json配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;watch&quot;:&quot;webpack --watch&quot;,</span><br><span class="line">  &quot;dev&quot;:&quot;webpack-dev-serve --open&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="CSS文件压缩"><a href="#CSS文件压缩" class="headerlink" title="CSS文件压缩"></a>CSS文件压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.先npm安装插件</span><br><span class="line">var OptimizeCSSAssetsPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">   	assetNameRegExp:&#x2F;\.css$&#x2F;g,</span><br><span class="line">   	cssProcessor:require(&#39;cssnano&#39;)</span><br><span class="line">   &#125;)</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure>

<h2 id="HTML-JS文件压缩"><a href="#HTML-JS文件压缩" class="headerlink" title="HTML/JS文件压缩"></a>HTML/JS文件压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先npm安装</span><br><span class="line">var HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line"> plugins: [</span><br><span class="line"> 		&#x2F;&#x2F;如果是多页面应用，需要为每个页面配置HtmlWebpackPlugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">    	templete:path.join(__dirname,&#39;src&#x2F;index.html&#39;),</span><br><span class="line">    	filename:&#39;index.html&#39;,</span><br><span class="line">    	chunks:[&#39;index&#39;],</span><br><span class="line">    	inject:true,</span><br><span class="line">    	minify:&#123;</span><br><span class="line">    		html5:true,</span><br><span class="line">    		collapseWhitespace:true,</span><br><span class="line">    		preserveLineBreaks:false,</span><br><span class="line">    		minifyCSS:true,</span><br><span class="line">    		minifyJS:true,</span><br><span class="line">    		removeComments:false</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>

<h2 id="自动清除构建目录"><a href="#自动清除构建目录" class="headerlink" title="自动清除构建目录"></a>自动清除构建目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.先npm安装插件</span><br><span class="line">var CleanWebpackPlugin &#x3D; require(&#39;clean-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new CleanWebpackPlugin()</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure>

<h1 id="postCSS"><a href="#postCSS" class="headerlink" title="postCSS"></a>postCSS</h1><p>postcss 一种对css编译的工具，类似babel对js的处理，常见的功能如：</p>
<p>1 . 使用下一代css语法</p>
<p>2 . 自动补全浏览器前缀</p>
<p>3 . 自动把px代为转换成rem</p>
<p>4 . css 代码压缩等等</p>
<p>postcss 只是一个工具，本身不会对css一顿操作，它通过插件实现功能，autoprefixer 就是其一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;postcss.config.js</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;1.css自动添加前缀</span><br><span class="line">npm i postcss-loader autoprefixer postcss-cssnext postcss-pxtorem -D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:&#x2F;\.css$&#x2F;g,</span><br><span class="line">			exclude:&#x2F;node_modules&#x2F;,</span><br><span class="line">			use:[</span><br><span class="line">				&#123;loader:&#39;style-loader&#39;&#125;,</span><br><span class="line">				&#123;loader:&#39;css-loader&#39;,options:&#123;</span><br><span class="line">					importLoaders:1</span><br><span class="line">				&#125;&#125;,</span><br><span class="line">				&#123;loader:&#39;postcss-loader&#39;&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &#39;autoprefixer&#39;: &#123;</span><br><span class="line">      overrideBrowserslist: [</span><br><span class="line">        &quot;Android 4.1&quot;,</span><br><span class="line">        &quot;iOS 7.1&quot;,</span><br><span class="line">        &quot;Chrome &gt; 31&quot;,</span><br><span class="line">        &quot;ff &gt; 31&quot;,</span><br><span class="line">        &quot;ie &gt;&#x3D; 8&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;postcss-pxtorem&#39;: &#123;</span><br><span class="line">      rootValue: 75, &#x2F;&#x2F;在html节点设置的font-size大小</span><br><span class="line">      unitPrecision:5,&#x2F;&#x2F;转rem小数点位数</span><br><span class="line">      propList: [&#39;*&#39;],	&#x2F;&#x2F;指定转成rem的属性，比如font-size,*表示全部</span><br><span class="line">      mediaQuery:false,&#x2F;&#x2F;媒体查询时是否转化</span><br><span class="line">      minPixelValue:0,&#x2F;&#x2F;小于多少px不转为rem</span><br><span class="line">      selectorBlackList:[&#39;.van&#39;]</span><br><span class="line">      &#x2F;&#x2F;特殊技巧:不转换成rem，px检测区分大小写，也就是说Px&#x2F;PX&#x2F;pX不会被转换，可以用这个方式避免转换成rem</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="font-size适配"><a href="#font-size适配" class="headerlink" title="font-size适配"></a>font-size适配</h2><ul>
<li>1.postcss-pxtorem</li>
<li>2.结合lib-flexible.js（根据rem动态计算font-size单位）</li>
</ul>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="文件指纹hash"><a href="#文件指纹hash" class="headerlink" title="文件指纹hash"></a>文件指纹hash</h2><blockquote>
<ul>
<li>Hash：只有项目中有文件变动了，hash值就会变化</li>
<li>chunkhash：和webpack打包的chunk有关，不同的entry会生成不同的chunkhash值</li>
<li>contenthash：根据文件内容来定义hash，只有文件内容有变动，hash就会变化</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const path&#x3D;require(&#39;path&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">	&#x2F;&#x2F;1.多页面</span><br><span class="line">	entry:&#123;</span><br><span class="line">		app1:&#39;.&#x2F;src&#x2F;index1.js&#39;,</span><br><span class="line">		app2:&#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">	output:&#123;</span><br><span class="line">		path:path.join(__dirname,&#39;dist&#39;),&#x2F;&#x2F;通过node中的path来制定路径</span><br><span class="line">		&#x2F;&#x2F;js文件用chunkhash</span><br><span class="line">		filename:&#39;[name][chunkhash:8].js&#39; &#x2F;&#x2F;通过占位符name来兼容多页面入口</span><br><span class="line">	&#125;,</span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#x2F;&#x2F;文件图片用hash</span><br><span class="line">			&#123;test:&#39;&#x2F;\.(png|jpeg|jpg|gif)$&#x2F;&#39;,use:[</span><br><span class="line">				&#123;loader:&quot;file-loader&quot;,</span><br><span class="line">				options:&#123;</span><br><span class="line">					name:[name][hash:8].[ext]</span><br><span class="line">				&#125;&#125;</span><br><span class="line">			]&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		&#x2F;&#x2F;css文件用contenthash</span><br><span class="line">		new MiniCssExtractPlugin(&#123;</span><br><span class="line">			filename:&#96;[name][contenthash:8].css&#96;</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p><img src="../../../../images/05/wy-06.png" alt="Image text"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-V8引擎内存模型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/30/V8%E5%BC%95%E6%93%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"
    >V8引擎内存模型</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/09/30/V8%E5%BC%95%E6%93%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2020-09-30T06:35:19.000Z" itemprop="datePublished">2020-09-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><h3 id="JavaScript是什么类型的语言"><a href="#JavaScript是什么类型的语言" class="headerlink" title="JavaScript是什么类型的语言"></a>JavaScript是什么类型的语言</h3><p>每种编程语言都有内建的数据模型，但它们的数据类型常有不同之处，使用方式也有不同。比如C，Java在使用变量之前，先要申明好数据类型，比如如下C代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int a &#x3D; 1;</span><br><span class="line">   char* b &#x3D; &quot; 极客时间 &quot;;</span><br><span class="line">   bool c &#x3D; true;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为<strong>静态语言。</strong></p>
<p>相反地，我们把在运行过程中需要检查数据类型的语言称为<strong>动态语言</strong>。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>
<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a</span><br></pre></td></tr></table></figure>

<p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，<strong>C 编译器会把 int 型的变量悄悄转换为 bool 型的变量</strong>，我们通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。</p>
<p>对于各种语言的类型，你可以参考下图</p>
<p><img src="../../../../images/04/wy-01.png" alt="Image text"></p>
<h3 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h3><p>现在我们知道了，JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？</p>
<ul>
<li><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>
<li><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据</li>
</ul>
<p>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar</span><br><span class="line">bar = <span class="number">12</span> </span><br><span class="line">bar = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">bar = <span class="literal">true</span></span><br><span class="line">bar = <span class="literal">null</span></span><br><span class="line">bar = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p>
<p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用“typeof”运算符。具体使用方式如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar)  <span class="comment">//undefined</span></span><br><span class="line">bar = <span class="number">12</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar) <span class="comment">//number</span></span><br><span class="line">bar = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar)<span class="comment">//string</span></span><br><span class="line">bar = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar) <span class="comment">//boolean</span></span><br><span class="line">bar = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar) <span class="comment">//object</span></span><br><span class="line">bar = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar) <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p>
<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>
<p><img src="../../../../images/04/wy-02.png" alt="Image text"></p>
<p>了解这些类型之后，还有三点需要你注意一下。</p>
<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>
<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  name:<span class="string">&#x27;极客时间&#x27;</span>,</span><br><span class="line">  update:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p>
<p>第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>
<h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>JS的内存分布也比较简单，如图示：</p>
<p><img src="../../../../images/04/wy-03.png" alt="Image text"></p>
<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。</p>
<p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p>
<h3 id="栈和堆-1"><a href="#栈和堆-1" class="headerlink" title="栈和堆"></a>栈和堆</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    <span class="keyword">var</span> c = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> d = c</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。</p>
<p><img src="../../../../images/04/wy-04.png" alt="Image text"></p>
<p>可以看到，普通变量是直接存储在执行上下文中，但是对象变量执行上下文中存储的是堆中的一个内存地址，实际存储该变量的内存空间是堆。</p>
<p>也就是说：</p>
<p>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p>
<p><strong>答案是不可以的。</strong>这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>
<p><img src="../../../../images/04/wy-05.png" alt="Image text"></p>
<h3 id="闭包的内存模型"><a href="#闭包的内存模型" class="headerlink" title="闭包的内存模型"></a>闭包的内存模型</h3><p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123; </span><br><span class="line">        setName:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;,</span><br><span class="line">        getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot; 极客邦 &quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>简单分析下上述代码的内存模型</p>
<ul>
<li>先创建一个全局的执行上下文，存储有变量函数foo，指向储存函数代码的地址</li>
<li>执行foo函数，创建foo的执行上下文</li>
<li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo - 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li>
<li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</li>
<li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中</li>
</ul>
<p>通过上面的分析，我们可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：</p>
<p><img src="../../../../images/04/wy-06.png" alt="Image text"></p>
<p>当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。</p>
<p>总的来说，产生闭包的核心有两步：</p>
<ul>
<li><p>第一步是需要预扫描内部函数；</p>
</li>
<li><p>第二步是把内部函数引用的外部变量保存到堆中。</p>
</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="调用栈中内存回收"><a href="#调用栈中内存回收" class="headerlink" title="调用栈中内存回收"></a>调用栈中内存回收</h3><p>调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>
<p><img src="../../../../images/04/wy-07.png" alt="Image text"></p>
<p>执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个<strong>记录当前执行状态的指针</strong>（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>
<p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。</p>
<p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图</p>
<p><img src="../../../../images/04/wy-08.png" alt="Image text"></p>
<p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>
<p>所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p>
<h3 id="堆中内存回收"><a href="#堆中内存回收" class="headerlink" title="堆中内存回收"></a>堆中内存回收</h3><p>在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>
<p>一般有两个回收器，分别为：新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）</p>
<p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>
<ul>
<li>副垃圾回收器，主要负责新生代的垃圾回收。</li>
<li>主垃圾回收器，主要负责老生代的垃圾回收。</li>
</ul>
<p><img src="../../../../images/04/wy-09.png" alt="Image text"></p>
<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><ul>
<li>新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域</li>
<li>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</li>
<li>垃圾清理的过程中，会先对对象做标记，标记完成后，进行垃圾清理阶段，同时生下来的对象会有序的复制到空闲区域中，清空对象区域，然后对象区域和空闲区域进行角色反转。</li>
<li>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</li>
<li>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</li>
</ul>
<h4 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h4><p>除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，</p>
<ul>
<li><p>一个是对象占用空间大，</p>
</li>
<li><p>一个是对象存活时间长。</p>
</li>
</ul>
<p>主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的</p>
<ul>
<li>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</li>
<li>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</li>
</ul>
<p><img src="../../../../images/04/wy-10.png" alt="Image text"></p>
<ul>
<li>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图</li>
</ul>
<p><img src="../../../../images/04/wy-11.png" alt="Image text"></p>
<h3 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h3><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p>
<p><img src="../../../../images/04/wy-12.png" alt="Image text"></p>
<p>为了改变这种垃圾回收造成明显性的页面卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：</p>
<p><img src="../../../../images/04/wy-13.png" alt="Image text"></p>
<h2 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h2><p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>
<p>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</p>
<p>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p>
<p>那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图</p>
<p><img src="../../../../images/04/wy-14.png" alt="Image text"></p>
<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>
<ol>
<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</li>
<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>
</ol>
<h3 id="V8是如何执行一段代码的"><a href="#V8是如何执行一段代码的" class="headerlink" title="V8是如何执行一段代码的"></a>V8是如何执行一段代码的</h3><p><img src="../../../../images/04/wy-15.png" alt="Image text"></p>
<p>从图中可以清楚地看到，V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan，那么它们是如何配合去执行一段 JavaScript 代码的呢? 下面我们就按照上图来一一分解其执行流程。</p>
<p><strong>1. 生成抽象语法树（AST）和执行上下文</strong></p>
<p>将源代码转换为抽象语法树，并生成执行上下文，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p>
<p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p>
<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>
<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line">myName = <span class="string">&quot;geektime&quot;</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>这段代码经过javascript-ast站点处理后，生成的 AST 结构如下：</p>
<p><img src="../../../../images/04/wy-16.png" alt="Image text"></p>
<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>
<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>
<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>
<p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p>
<p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>
<p><img src="../../../../images/04/wy-17.png" alt="Image text"></p>
<p>从图中可以看出，通过var myName = “极客时间”简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p>
<p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
<p>这就是 AST 的生成过程，先分词，再解析。</p>
<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p>
<p><strong>2. 生成字节码</strong></p>
<p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>
<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>
<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>
<p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>
<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图</p>
<p><img src="../../../../images/04/wy-18.png" alt="Image text"></p>
<p><strong>3. 执行代码</strong></p>
<p>生成字节码之后，接下来就要进入执行阶段了。</p>
<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。<strong>在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，</strong>然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>
<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</p>
<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>
<p>对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>
<p>这么多语言的工作引擎都使用了“字节码 +JIT”技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>
<p><img src="../../../../images/04/wy-19.png" alt="Image text"></p>
<h3 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h3><p>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>
<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容</p>
<ul>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/V8/" rel="tag">V8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="tag">内存模型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> YOUNG
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="YOUNG BLOG"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>